/**
 * File:	modules/Instserver.ycp
 * Package:	Configuration of Installation Server
 * Summary:	Installation Server settings, input and output functions
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of Installation Server.
 * Input and output routines.
 */

{

module "Instserver";
textdomain "instserver";

import "Progress";
import "Report";
import "Summary";
import "XML";
import "Popup";
import "Package";
import "Call";
import "Service";
import "SLP";
import "IP";
import "Message";
import "SuSEFirewall";
import "String";

include "instserver/routines.ycp";


// Is this a service pack?
global boolean is_service_pack = false;

global boolean test = false;

/* Configuration Map */
global map<string, any> Config = $[];

/* All Configurations */
global map<string, map<string, any> > Configs = $[];

/* Server Configuration */
global map ServerSettings = $[];

/* Configuration Repository */
global string Rep = "/etc/YaST2/instserver";

/* config file */
string ConfigFile = Rep + "/instserver.xml";


global string FirstDialog = "summary";


global list<map> products = [];


global list<string> Detected = [];

global boolean standalone = false;

// renamed repositories: $["old" : "new"]
global map<string, string> renamed = $[];


/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;



global list<string> to_delete = [];

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean AbortFunction = Modified();

/**
 * Abort function
 * @return boolean
 */
global define boolean Abort() {
    if(AbortFunction != nil)
	return (boolean)eval(AbortFunction);
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}


boolean vsftpd_is_standalone()
{
    boolean ret = SCR::Execute(.target.bash, "grep -q '^listen=YES$' /etc/vsftpd.conf") == 0;

    y2milestone("vsftpd in standalone mode: %1", ret);
    return ret;
}

/**
 * Create links
 */
global list<string> createLinks (string dir, string product, list<string> files)
{
    string shorttgt = sformat("%1/CD%2",  product, 1 );
    list<string> cmds = [];

    foreach(string symlink , files, ``{
	string f = sformat("%1/%2/%3", dir, shorttgt, symlink );

	// always return success - the link may be missing if the target file doesn't exist
	cmds=add(cmds, sformat("( test -f %1 || test -d %2) &&  pushd %3 && ln -sf %4/%5 && popd; exit 0",
			       f,f,dir, shorttgt, symlink));

    });
    cmds=add(cmds, sformat("mkdir -p %1/yast", dir));

    y2debug("cmds: %1", cmds );
    return cmds;
}


/**
 * Create yast directory with ordr/instorder files
 * @param string directory
 * @return booelan 
 */
global boolean createOrderFiles(string dir)
{
    if (size(products) > 1 )
    {
        SCR::Execute(.target.mkdir, dir + "/yast");

	y2milestone("products: %1", products);
        // create order: Service Packs, products which require any other product, other products
        list<map> order = filter(map p, products, ``(p["SP"]:false));
        order = (list<map>)union(order, filter(map p, products, ``(!p["baseproduct"]:false && !p["SP"]:false)));
        order = (list<map>)union(order, filter(map p, products, ``(p["baseproduct"]:false && !p["SP"]:false)));
        y2milestone("order: %1", order );

        list<map> instorder = filter(map p, products, ``(p["baseproduct"]:false));
        instorder = (list<map>)union(instorder, filter(map p, products, ``(!p["baseproduct"]:false)));

        // HACK: support sles8 too
        list<map> ul = filter(map u, instorder ,
                ``(issubstring(tolower(u["name"]:""), "unitedlinux")));
        if (size(ul) == 0) {
            instorder = order;
        }
        y2milestone("instorder: %1", instorder );

        list<string> file = [];
        foreach (map p, order , ``{
		// workaround for NLD9 - if the subdir doesn't exists use root
		string proddir = (SCR::Read(.target.size, dir + "/" + p["name"]:"") < 0) ?
		    "/" : sformat("/%1/CD1", p["name"]:"" );

                file = add(file, mergestring([  proddir, proddir ], "\t"));
                });
        file = add(file , "");
        SCR::Write(.target.string, dir + "/yast/order",  mergestring(file, "\n"));
        file = [];
        foreach (map p, instorder , ``{
		// workaround for NLD9 - if the subdir doesn't exists use root
		string proddir = (SCR::Read(.target.size, dir + "/" + p["name"]:"") < 0) ?
		    "/" : sformat("/%1/CD1", p["name"]:"" );

                file = add(file, proddir);
                });
        file = add(file , "");
        SCR::Write(.target.string, dir + "/yast/instorder",  mergestring(file, "\n"));
    }
    products = [];

    return true;
}


/**
  * Mount directory to avoid symlinks
  * @param string directory to bind
  * @param string bind to
  * @return boolean (true means that /etc/fstab has been modified)
  */
boolean MountBind( string dir, string ftproot)
{
    y2milestone("Calling MountBind with: %1 %2", dir, ftproot );
    list<map> fstab = (list<map>)SCR::Read(.etc.fstab);
    y2debug("fstab: %1", fstab );
    list<map> exists = filter(map f, fstab, ``(f["spec"]:"" == deletechars(dir, " ")));
    y2milestone("existing: %1", exists );
    if (size(exists)> 0 )
    {
        return false;
    }
    else
    {
        SCR::Execute(.target.mkdir, ftproot);
	y2milestone("mounting %1 to %2", dir, ftproot);
        SCR::Execute(.target.mount, [ dir, ftproot], "--bind" );

        map bindfs = $[];
        bindfs = $["file":ftproot, "spec":dir, "freq":1,
	    "mntops":"bind", "passno":1, "vfstype":"auto"];

        fstab = add(fstab, bindfs);

	y2milestone("added /etc/fstab entry: %1", bindfs);
        SCR::Write(.etc.fstab, fstab);
    }
    return true;
}


/**
 * Configure service using _auto
 */
boolean ConfigureService(string module_auto, any resource) {
    y2milestone("New configuration for service %1: %2", module_auto, resource);

    boolean ret = false;
    ret = (boolean)Call::Function(module_auto, ["Import", resource]);
    ret = (boolean)Call::Function(module_auto, ["Write",  resource]);
    return ret;
}

/**
 * Read service data using _auto
 */
any ReadServiceSettings(string module_auto) {
    boolean r  = (boolean)Call::Function(module_auto, ["Read"]);
    any ret = Call::Function(module_auto, ["Export"]);

    y2milestone("Current configuration of service %1: %2", module_auto, ret);

    return ret;
}

global boolean InstallFTPPackages()
{
    string help = _("The FTP installation server requires an FTP server package. The vsftpd package
will now be installed.
");
    if ( !Package::InstalledAll( [ "xinetd", "vsftpd", "openslp-server", "yast2-inetd" ] ) ) {
        y2milestone("some packages are not installed");
    }
    else
    {
	return true;
    }

    if ( !Package::InstallAll( [ "xinetd", "vsftpd" , "openslp-server", "yast2-inetd"])) {
	Report::Error( Message::CannotContinueWithoutPackagesInstalled() );
        y2error("Error while installing packages");
        return false;
    }

    return true;
}

/**
 * Setup FTP server
 * @param string inst server root
 * @param string ftp server root
 * @return boolean
 */
global boolean SetupFTP(string dir, string ftproot, string ftpalias) {

    if (!InstallFTPPackages())
    {
	return false;
    }

    // create repository directory if it doesn't exist
    SCR::Execute(.target.bash, sformat("[ -d %1 ] || /bin/mkdir %1", dir));

    if (!issubstring(dir, ftproot))
    {
        if (ftpalias != "")
        {
	    string a = "";
            a = ftproot + "/" + ftpalias;
            SCR::Execute(.target.bash,"mkdir -p " + a);
	    ftproot = a;
        }
        y2milestone("binding dir");
        MountBind(dir, ftproot);
    } else {
        // FIXME
        y2warning("not implemented");
    }

    // check if vsftpd is configured in standalone mode (listen=YES) (bnc#438694)
    // see 'man vsftpd.conf'
    boolean vsftpd_standalone = vsftpd_is_standalone();

    if (vsftpd_standalone)
    {
	y2milestone("Configuring FTP service in standalone mode");

	// enable/start the service
	Service::Enable("vsftpd");
	if (Service::Status("vsftpd") == 0 )
	    Service::Reload("vsftpd");
	else
	    Service::Start("vsftpd");
    }
    else
    {
	y2milestone("Configuring FTP service in xinetd mode");
	// read the current configuration
	map resource = (map)ReadServiceSettings("inetd_auto");
	list<map> netdconf = [];

	// replace vsftpd config
	boolean ftpdenabled = false;
	boolean servicefound = false;
	foreach(map conf, resource["netd_conf"]:[], {
		// the service is ftp with vsftpd server
		if (conf["service"]:"" == "ftp" && conf["script"]:"" == "vsftpd")
		{
		    servicefound = true;

		    // enable disabled service
		    if (conf["enabled"]:false != true)
		    {
			conf["enabled"] = true;
		    }
		    else
		    {
			ftpdenabled = true;
		    }
		}

		// add the configuration to the list
		netdconf = add(netdconf, conf);
	    }
	);

	if (servicefound == false)
	{
	    // the FTP service config was not found, add it
	    map vsftpdconf =  $["protocol":"tcp", "script":"vsftpd", "server":"/usr/sbin/vsftpd", "service":"ftp"];
	    netdconf = add(netdconf, vsftpdconf);
	}

	// ftp service was not enabled/configured
	if (ftpdenabled == false)
	{
	    // update the configuration
	    resource["netd_conf"] = netdconf;

	    // write the configuration
	    ConfigureService("inetd_auto", resource);
	}

	// enable/start the service
	Service::Enable("xinetd");
	if (Service::Status("xinetd") == 0 )
	    Service::Reload("xinetd");
	else
	    Service::Start("xinetd");
    }

    return true;
}

/**
 * Write Apache config
 * @param string state : Yes/No
 * @return void
 */
define void RunSuseConfigApache( boolean enable ) ``{
    string flags = (string) SCR::Read( .sysconfig.apache2.APACHE_SERVER_FLAGS );
    if (!issubstring(flags,"inst_server") && enable)
        SCR::Write( .sysconfig.apache2.APACHE_SERVER_FLAGS, flags + " inst_server" );
    else if (issubstring(flags,"inst_server") && !enable)
        SCR::Write( .sysconfig.apache2.APACHE_SERVER_FLAGS, regexpsub(flags, "(.*)inst_server(.*)", "\1 \2" ) );

    if( !SCR::Write( .sysconfig.apache2, nil ) ) {
        Popup::Error( _("Unable to write /etc/sysconfig/apache2") );
        return;
    }
}

global boolean InstallHTTPPackages()
{
    string help = _("The HTTP installation server requires an HTTP server package. The apache2 package
will now be installed.");
     if ( !Package::InstalledAll( [ "apache2" , "openslp-server" ] ) ) {
        y2debug("some packages are not installed");

         if ( !Package::InstallAll( [ "apache2" , "apache2-prefork", "openslp-server" ] ) ) {
	    Report::Error( Message::CannotContinueWithoutPackagesInstalled() );

            y2error("Error while installing packages");
            return false;
        } 
    }

    return true;
}

/**
 * Setup HTTP server
 * @param string inst server root
 * @param string alias
 * @return boolean
 */
global boolean SetupHTTP(string dir, string alias) {

    if (!InstallHTTPPackages())
    {
	return false;
    }

    if ((integer)SCR::Read(.target.size, "/etc/apache2/conf.d/inst_server.conf.in") > 0 )
    {
        string conf = (string)SCR::Read(.target.string, "/etc/apache2/conf.d/inst_server.conf.in");
        list<string> confline = splitstring(conf, "\n");

        if (findfirstof(alias, "/") != 0 )
            alias = "/" + alias;
        confline = maplist(string line, confline, ``{
                any res = regexpsub(line , "(.*)@ALIAS@(.*)", sformat("\\1%1/\\2", alias ));
                res = regexpsub((res!=nil) ?(string)res:line , "(.*)@SERVERDIR@(.*)", sformat("\\1%1/\\2", dir ));
                if (res != nil)
                return ((string)res);
                else
                return (line);
                });

        y2debug("conf: %1", confline);

        conf = mergestring(confline, "\n");
        if (!SCR::Write(.target.string, "/etc/apache2/conf.d/inst_server.conf", conf ))
        {
            y2error("Error writing apache2 config file");
        }
    } else {
	y2error("/etc/apache2/conf.d/inst_server.conf.in does not exist");
        return false;
    }
    RunSuseConfigApache(true);

    // write firewall config if it has been modified
    if (SuSEFirewall::GetModified())
    {
	SuSEFirewall::Write();
    }

    Service::Enable("apache2");
    if (Service::Status("apache2") == 0 )
        Service::Reload("apache2");
    else
        Service::Start("apache2");
    return true;
}


/**
 * Setup NFS Server
 * @param string directory
 * @param string options
 * @return boolean
 */
global boolean SetupNFS(string dir, string options) {

    if (!Package::InstallAll( [ "yast2-nfs-server"])) {
	Report::Error( Message::CannotContinueWithoutPackagesInstalled() );

        y2error("Error while installing packages");
        return false;
    }

    map resource = (map)ReadServiceSettings("nfs_server_auto");
    list<map> oldexp = resource["nfs_exports"]:[];
    y2milestone("oldexp: %1", oldexp );

    list oldexists = filter(map e, oldexp, ``(e["mountpoint"]:"" == dir) );
    if (size(oldexists) > 0 ) {
        boolean yesno = Popup::YesNo(_("Directory is already exported via NFS.
Leave NFS exports unmodified?
"));
        if (yesno)
        {
            return true;
        }
        else
        {
            oldexp = filter(map e, oldexp, ``(e["mountpoint"]:"" != dir) );
        }
    }
    list<map> exports = oldexp;
    map nfs = $[];
    nfs["start_nfsserver"] = true;
    list allowed = [];
    if (size(options) == 0 ) {
        options = "*(ro,root_squash,sync,no_subtree_check)";
    }
    allowed=add(allowed, options);
    map ex = $[];
    ex["allowed"] = allowed;
    ex["mountpoint"] = dir;
    exports=add(exports, ex);
    nfs["nfs_exports"] = exports;

    ConfigureService("nfs_server_auto", nfs);

    Service::Enable("nfsserver");
    if (Service::Status("nfsserver") == 0 )
        Service::Reload("nfsserver");
    else
        Service::Start("nfsserver");

    // write firewall config if it has been modified
    if (SuSEFirewall::GetModified())
    {
	SuSEFirewall::Write();
    }

    return true;
}

// some values are not allowed in SLP attributes
// and must be escaped ('\' followed by two hex numbers)
// see RFC2614 (http://www.openslp.org/doc/rfc/rfc2614.txt)
map<string, string> EscapeSLPData(map<string, string> a)
{
    map<string, string> ret = $[];

    foreach(string key, string value, a,
	{
	    // String::Replace() enters endless loop in '\' -> '\5c' conversion
	    // use splitstring() and mergestring() builtins instead
	    string new_key = mergestring(splitstring(key, "\\"), "\\5c");
	    new_key = String::Replace(new_key, ".", "\\2e");
	    new_key = String::Replace(new_key, "=", "\\3d");
	    new_key = String::Replace(new_key, "#", "\\23");
	    new_key = String::Replace(new_key, ";", "\\3b");

	    string new_value = mergestring(splitstring(value, "\\"), "\\5c");
	    new_value = String::Replace(new_value, "(", "\\28");
	    new_value = String::Replace(new_value, ")", "\\29");
	    new_value = String::Replace(new_value, ",", "\\2c");
	    new_value = String::Replace(new_value, "#", "\\23");
	    new_value = String::Replace(new_value, ";", "\\3b");

	    ret[new_key] = new_value;
	}
    );

    y2milestone("Escaped SLP attributes: %1 -> %2", a, ret);

    return ret;
}

string subreplace(string text, string in, string out)
{
    list<string> parts = splitstring(text, "\\");

    // don't modify the first item, it's the non-matched prefix
    boolean first = true;
    list<string> new_parts = maplist(string p, parts,
        {
	    if (first)
	    {
		first = false;
		return p;
	    }

	    string new_part = p;

	    if (in == substring(p, 0, 2))
	    {
		new_part = out + substring(p, 2);
	    }
	    else
	    {
		// put the backslash back if the remaining part doesn't match
		new_part = "\\" + p;
	    }

	    return new_part;
	}
    );

    string ret = mergestring(new_parts, "");
    y2debug("unescaped str: text: %1, in: %2, out: %3 => %4", text, in, out, ret);

    return ret;
}

// this is an oppsite function to EscapeSLPData()
// it takes SLP input and unescpaes the backslash sequences
map<string, string> UnEscapeSLPData(map<string, string> a)
{
    map<string, string> ret = $[];

    foreach(string key, string value, a,
	{
	    // String::Replace() enters endless loop in '\' -> '\5c' conversion
	    // use splitstring() and mergestring() builtins instead
	    string new_key = key;
	    new_key = subreplace(new_key, "2e", ".");
	    new_key = subreplace(new_key, "3d", "=");
	    new_key = subreplace(new_key, "23", "#");
	    new_key = subreplace(new_key, "3b", ";");
	    new_key = subreplace(new_key, "5c", "\\");

	    string new_value = value;
	    new_value = subreplace(new_value, "28", "(");
	    new_value = subreplace(new_value, "29", ")");
	    new_value = subreplace(new_value, "2c", ",");
	    new_value = subreplace(new_value, "23", "#");
	    new_value = subreplace(new_value, "3b", ";");
	    new_value = subreplace(new_value, "5c", "\\");

	    ret[new_key] = new_value;
	}
    );

    y2milestone("Unescaped SLP attributes: %1 -> %2", a, ret);

    return ret;
}

/*
 * Return the IP address of the local machine	
 * @return string IP Address
 */
global string GetIPAddr()
{
    list<map> ifconfig =(list<map>)SCR::Read(.run.ifconfig);
    list<map> ifc = filter(map iface, ifconfig, ``( iface["name"]:"" == "eth0"));
    integer ip = ifc[0,"value", "inet", "addr"]:0;
    if (ip == 0)
    {
	ifc = filter(map iface, ifconfig, ``( iface["name"]:"" != "lo" && !issubstring(iface["name"]:"", "dummy") && iface["value", "inet", "addr"]:0 != 0));
	if (ifc != nil) 
	{
		ip = ifc[0,"value", "inet", "addr"]:0;
	}
    }

    return (IP::ToString(ip));
}

global string GetHostname()
{
    map output = (map)SCR::Execute( .target.bash_output, "/bin/hostname --long" );
    y2milestone("hostname --long: %1", output);
    string hostname = output["stdout"]:"";

    hostname = splitstring(hostname, "\n")[0]:"";

    return hostname;
}

list<string> basearch_mapping(string basearch)
{
    map<string,list<string> > mapping = $[
	"i586"	: [ "i586", "i686" ],
        "mips"	: [ "mips", "mips64" ],
        "ppc"	: [ "ppc", "ppc64" ],
        "sparc"	: [ "sparc", "sparc64"],
	"x86_64" : [ "x86_64"]
    ];

    if (!haskey(mapping, basearch))
    {
	y2warning("Unknown BASEARCH: %1", basearch);
    }

    // return the original basearch if mapping is unknown
    list<string> ret = mapping[basearch]:[basearch];

    y2milestone("Using BASEARCH mapping: %1 -> %2", basearch, ret);

    return ret;
}

list<string> get_machines(string basearch_value)
{
    list<string> archs = splitstring(basearch_value, " ");
    archs = filter(string a, archs, {return a != nil && a != "";});

    list<string> ret = [];

    foreach(string a, archs,
	{
	    ret = (list<string>)merge(ret, basearch_mapping(a));
	}
    );

    y2milestone("Final BASEARCH mapping: %1", ret);

    return ret;
}


/**
 * Write SLP configuration
 */
global boolean WriteSLPReg (map<string,any> cm) {

    y2debug("WriteSLPReg(%1)", cm);

    string ip = GetIPAddr();
    string hostname = GetHostname();
    string serv = "";
    string regfile =  sformat("YaST-%1.reg",  cm["name"]:"" );
    if (ServerSettings["service"]:`none == `nfs)
    {
        serv =  sformat("service:install.suse:nfs://%1/%2/%3%4,en,65535",
                ip,
                ServerSettings["directory"]:"", cm["name"]:"",
                "/CD1" );
    }
    else if (ServerSettings["service"]:`none == `ftp)
    {
        serv =  sformat("service:install.suse:ftp://%1/%2%3,en,65535", ip,
                cm["name"]:"", "/CD1");
    }
    else if (ServerSettings["service"]:`none == `http)
    {
        serv = sformat("service:install.suse:http://%1/%2/%3%4,en,65535",
                ip,
                ServerSettings["alias"]:"", cm["name"]:"",
                "/CD1");
    }

    map<string, string> attr = $[];
    foreach(string a, ["LABEL", "VERSION", "VENDOR", "DEFAULTBASE", "BASEPRODUCT", "BASEVERSION"], ``{
        if (cm[a]:"" != "" )
        {
            attr[tolower(a)] =  cm[a]:"";
        }
        });

    // Check if the description is already used
    // don't check file which will be rewritten
//    string checkfiles = "/etc/slp.reg.d/YaST-*.reg";
    string targetfile = "/etc/slp.reg.d/" + regfile;

    string hostname_reg = "";
    // add the hostname
    if (hostname != nil && hostname != "" && haskey(attr, "label"))
    {
	hostname_reg = hostname + ": ";
    }

    string descr = hostname_reg + cm["LABEL"]:"";
    if (cm["DISTPRODUCT"]:"" != "")
    {
	descr = descr + sformat(" [%2]", cm["DISTPRODUCT"]:"");
    }

    attr["description"] = descr;

    string read_file = targetfile;

    foreach(string orig, string new, renamed,
	{
	    if (new == cm["name"]:"")
	    {
		y2milestone("Config renamed from %1 to %2", orig, new);

		read_file = "/etc/slp.reg.d/" + sformat("YaST-%1.reg", orig);
	    }
	}
    );

    string machine = "";
    list<string> machines = [];
    foreach(string k, any v, cm, ``{
	    y2debug("Read Key: '%1'", k);

	    if (k == "BASEARCHS")
	    {
		// machine mapping
		machines = get_machines((string)v);
	    }
            else if (issubstring(k, "ARCH"))
            {
		string a = regexpsub(k, "ARCH\\.(.*)", "\\1");

		if (a != nil)
		{
		    y2milestone("Found %1 key, adding arch %2 to the list", k, a);
		    machines = add(machines, a);
		}
            }
            });
    machines = filter(string m , machines, ``(m!="" && m!="noarch"));
    machines = toset(machines);

    // sort the list so it looks better
    machines = sort(machines);
    string machines_string = mergestring(machines, ",");

    y2debug("machines: %1", machines);

    // preserve the old configuration
    if (SCR::Read(.target.size, read_file) >= 0)
    {
	y2milestone("Existing reg.d file found: %1", read_file);
	map<string, string> old_attr = $[];

	string reg_cont = (string)SCR::Read(.target.string, read_file);
	list<string> lines = splitstring(reg_cont, "\n");

	foreach(string l, lines,
	    {
		string parsed_name = regexpsub(l, "^[ \t]*([^ \t]*)[ \t]*=(.*)", "\\1");
		string parsed_value = regexpsub(l, "^[ \t]*([^ \t]*)[ \t]*=(.*)", "\\2");
		if (parsed_name != nil)
		{
		    y2milestone("Reusing attribute: %1=%2", parsed_name, parsed_value);
		    old_attr[parsed_name] = parsed_value;
		}
	    }
	);

	// unescape the read value
	old_attr = UnEscapeSLPData(old_attr);

	if (haskey(old_attr, "machine"))
	{
	    // backup the "machine" value
	    machines_string = old_attr["machine"]:"";
	}

	// merge them with read values,
	// keep the original setting if a value was already set
	attr = (map<string, string>)union(attr, old_attr);

/*
TODO: checking?
	// don't check the overwritten config file
	// get names of all config files except the rewritten one
	map lsout = (map)SCR::Execute(.target.bash_output, "/bin/ls /etc/slp.reg.d/* | grep -v /etc/slp.reg.d/YaST-sles9.reg");
	if (lsout["exit"]:-1 == 0)
	{
	    // merge the output into single line
	    checkfiles = mergestring(splitstring(lsout["stdout"]:"", "\n"), " ");
	    y2debug("files to check: %1", checkfiles);
	}
*/
    }

    // escape invalid characters
    attr = EscapeSLPData(attr);

    // replace the machine option after escaping,
    // it actually _is_ a list so "," is valid here
    attr["machine"] = machines_string;
    y2milestone("machine: %1", attr["machine"]:"");

    y2milestone("registering SLP service: serv: %1, attr: %2, regfile: %3", serv, attr, regfile);

    boolean ret = SLP::RegFile(serv, attr, regfile );

    return ret;
}



global list<string> DetectMedia() {
    if (ServerSettings["directory"]:"" != "")
    {
        string f = sformat("find %1 -maxdepth 2 -name %2 | grep -v yast",
                ServerSettings["directory"]:"", "content");
        map ret = (map)SCR::Execute (.target.bash_output, f);
        list<string> found = splitstring(ret["stdout"]:"", "\n");
        found = filter(string s, found, ``(s!=""));
        found = filter(string file, found, ``{
                string d = dirname(file);
                string media = sformat("%1/media.1/media", d);
                return (SCR::Read(.target.size, media)!= -1 );
                });
        y2debug("media: %1", found);
        return found;
    }
    else
    {
        return ([]);
    }
}

global define map<string, map> FindAvailable() ``{
    map<string, map> Available = $[];
    foreach(string c, Detected, ``{
            map ret = ReadContentFile(c);
            string d = dirname(c);
            string config_name = basename(d);
            if (ret != $[] && !haskey(Configs, config_name))
            {
            Available[d]= ret;
            }
            });
    return Available;
}

boolean NFSExported(string dir)
{
    map nfs_config = (map)ReadServiceSettings("nfs_server_auto");
    list<map> exports = nfs_config["nfs_exports"]:[];

    boolean ret = false;

    foreach(map e, exports,
	{
	    if (e["mountpoint"]:"" == dir)
	    {
		ret = true;
	    }
	}
    );

    y2milestone("Directory %1 is exported: %2", dir, ret);

    return ret;
}

boolean NFSValid(map config)
{
    string dir = config["directory"]:"";

    if (dir == nil || dir == "")
    {
	y2milestone("Empty or missing directory in the configuration");
	return false;
    }

    // is the directory in /etc/exports?
    if (!NFSExported(dir))
    {
	return false;
    }

    boolean nfsserver_running = Service::Status("nfsserver") == 0;
    y2milestone("NFS server running: %1", nfsserver_running);

    // is the nfsserver running?
    return nfsserver_running;
}

boolean FTPValid(map config)
{
    if (vsftpd_is_standalone())
    {
	// is the service running?
	boolean ret = (Service::Status("vsftpd") == 0 );
	y2milestone("FTP (vsftpd) server running: %1", ret);

	return ret;
    }

    // read the current configuration
    map resource = (map)ReadServiceSettings("inetd_auto");

    // check vsftpd config
    boolean ftpdenabled = false;
    boolean servicefound = false;

    foreach(map conf, resource["netd_conf"]:[], {
	    // the service is ftp with vsftpd server
	    if (conf["service"]:"" == "ftp" && conf["script"]:"" == "vsftpd")
	    {
		servicefound = true;
		// the default is true: missing tag means the service is enabled (!)
		ftpdenabled = conf["enabled"]:true;
	    }
	}
    );

    y2milestone("FTP service check: found: %1, enabled: %2", servicefound, ftpdenabled);

    if (servicefound == false || ftpdenabled == false)
    {
	return false;
    }

    // is the service running?
    boolean ret = (Service::Status("xinetd") == 0 );
    y2milestone("FTP server running: %1", ret);

    return ret;
}

boolean HTTPValid(map config)
{
    string config = "/etc/apache2/conf.d/inst_server.conf";

    // is the config missing
    integer config_size = (integer)SCR::Read(.target.size, config);
    y2milestone("Size of %1: %2", config, config_size);

    if (config_size <= 0)
    {
	y2warning("Missing config file: %1", config);
	return false;
    }

    // is the service running?
    boolean ret = (Service::Status("apache2") == 0 );
    y2milestone("HTTP server running: %1", ret);

    return ret;
}

boolean ServiceValid(map config)
{
    symbol service = (symbol)config["service"]:`unknown;

    if (service == `nfs)
    {
	return NFSValid(config);
    }
    else if (service == `ftp)
    {
	return FTPValid(config);
    }
    else if (service == `http)
    {
	return HTTPValid(config);
    }

    y2warning("Unknown service type %1, cannot check configuration", service);

    return false;
}

/**
 * Read all instserver settings
 * @return true on success
 */
global boolean Read() {

    /* Instserver read dialog caption */
    string caption = _("Initializing Configuration");

    integer steps = 4;

    integer sl = 1;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Read configuration file"),
	    /* Progress stage 2/2 */
	    _("Search for a new repository"),
	], [
	    /* Progress step 1/2 */
	    _("Reading configuration file..."),
	    /* Progress step 2/2 */
	    _("Searching for a new repository..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();
    map c = $[];


    if (SCR::Read(.target.size, ConfigFile) != -1 )
    {
        c = XML::XMLToYCPFile(ConfigFile);
    }
    list<map<string, any > > all = c["configurations"]:[];
    ServerSettings = c["servers"]:$[];

    Configs = listmap (map<string, any> i, all, ``{
            string name = i["name"]:"";
            return($[name: i]);
            });
    y2milestone("Configs: %1", Configs);

    ServerSettings = c["servers"]:$[];
    y2milestone("Server config: %1", ServerSettings);

    // check the server status here
    if (ServerSettings == $[] || !ServiceValid(ServerSettings))
    {
        FirstDialog = "settings";
    }

    // disable progress for firewall
    boolean prg = Progress::set(false);
    // read firewall settings
    SuSEFirewall::Read();
    Progress::set(prg);

    sleep(sl);


    // read current settings
    if(Abort()) return false;
    Progress::NextStage();


    Detected = DetectMedia();

    /* Error message */
    if(false) Report::Error(_("Cannot read current settings."));
    sleep(sl);


    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}



/**
 * Prepare map for writing  into XML
 * @return lists of configurations
 */
define list PrepareConfigs() ``{

    list c = maplist(string k, map v, Configs, ``{
        return(v);
    });
    return (c);
}


/**
 * Write all instserver settings
 * @return true on success
 */
global boolean Write() {

    y2debug("Instserver::Write() called");

    /* Instserver read dialog caption */
    string caption = _("Saving Installation Server Configuration");

    integer steps = 2;

    integer sl = 1;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    list c = PrepareConfigs();
    map xml = $["configurations": c , "servers": ServerSettings ];
    boolean ret = XML::YCPToXMLFile(`instserver, xml, ConfigFile);

    /* Error message */
    if(false) Report::Error (_("Cannot write settings."));
    sleep(sl);

    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();

    boolean slpreload = false;

    list<string> regs_delete = to_delete;

    // remove the deleted repositories
    foreach(string c, regs_delete, ``{
       string dir = Instserver::ServerSettings["directory"]:"" + "/" + c;
       y2milestone("removing directory: %1", dir);

       string rm = "rm -rf " + dir;
       SCR::Execute(.target.bash, rm);
    });

    // add disabled SLP repositories
    foreach(string confname, map<string, any> conf, Instserver::Configs, {
	    if (conf["slp"]:true == false)
	    {
		regs_delete = add(regs_delete, conf["name"]:"");
	    }
	}
    );

    // Remove the SLP files of removed or SLP disabled repositories
    foreach(string c, regs_delete, ``{
       string regfile =  sformat("/etc/slp.reg.d/YaST-%1.reg",  c );
       if (SCR::Read(.target.size, regfile) > 0 )
       {
           slpreload = true;
           SCR::Execute(.target.remove, regfile);
       }
    });

    // Write all SLP files
    foreach(string cn, map<string, any> cm, Configs, ``{
            if (cm["slp"]:false)
            {
                string regfile =  sformat("/etc/slp.reg.d/YaST-%1.reg",  cm["name"]:"" );
                {
                    WriteSLPReg(cm);
		    slpreload = true;
                }
            }
        });

    // move content of the renamed repositories
    foreach(string orig, string new, renamed,
	{
	    // remove old reg file
	    string old_regfile = sformat("/etc/slp.reg.d/YaST-%1.reg", orig);
	    y2milestone("removing old reg file: %1", old_regfile);
	    SCR::Execute(.target.bash, "rm -f " + old_regfile );

	    // rename the directory
	    string cmd = sformat("mv %1/%2 %1/%3", Instserver::ServerSettings["directory"]:"", orig, new);
	    y2milestone("moving directory: %1", cmd);

	    if (SCR::Execute(.target.bash, cmd) != 0 )
	    {
		Popup::Error(_("Error while moving repository content."));
		continue;
	    }
	}
    );


    // slp service reload is required - the configuration has been changed
    if (slpreload)
    {
        if (Service::Status("slpd") == 0 )
	    Service::Restart("slpd");
        else
	    Service::Start("slpd");
    }

    if (Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    return true;
}


global define void UpdateConfig() ``{
    y2debug("current config: %1", Configs );

    string name = Config["name"]:"";
    string old_name = Config["old_name"]:"";

    // remove the old config
    if (haskey(Instserver::Configs, old_name) && old_name != "")
    {
        Configs = filter(string k, map<string, any> v, Configs, ``(k!=old_name));
        remove(Config, "old_name");
    }

    if (name != "")
    {
	// update the config
        Configs[name] = Config;
    }

    y2debug("current config: %1", Configs );
    return;
}


/**
 * Create XML Configuration
 * @return void
 */
global define void configSetup()
    ``{
    map doc = $[];
    doc["listEntries"] =
        $[
        ];
    doc["cdataSections"] = [];
    doc["rootElement"] = "instserver";
    doc["systemID"] = "/usr/share/YaST2/dtd/instserver.dtd";
    doc["nameSpace"] = "http://www.suse.com/1.0/yast2ns";
    doc["typeNamespace"] = "http://www.suse.com/1.0/configns";
    XML::xmlCreateDoc(`instserver, doc);
    return;
}


/**
 * Get all instserver settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    return true;
}

/**
 * Dump the instserver settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    return $[];
}




/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    /* Configuration summary text for autoyast */
    string sum = "";
    map<string, map> Available = filter( string d, map avail, FindAvailable(), ``(!haskey(Configs, basename(d))));
    list unconf = maplist(string d, map avail, Available, ``{
            string dir = basename(d);
            return(`item(`id(dir), avail["LABEL"]:"" + "(" + avail["DEFAULTBASE"]:"" + ")" )) ;
            });

    sum = Summary::AddHeader(sum, _("Configured Repositories"));
    sum = Summary::OpenList(sum);

    foreach(string name , map cfg, Configs , ``{
            string source = cfg["LABEL"]:"" + "<br><b>Architecture: </b>" + cfg["DEFAULTBASE"]:"";
            sum = Summary::AddListItem(sum, source);
            });
    sum = Summary::CloseList(sum);
    return [ sum, unconf ];
}

/**
 * Create an overview table with all configured data
 * @return table items
 */
global list Overview() {
    y2milestone("Configs: %1", Configs);
    list overview = maplist(string name , map cfg, Configs , ``{
            return(`item(`id(name), name, cfg["PRODUCT"]:"" + " " + cfg["VERSION"]:""));
            });
    return overview;

}


/**
 * Constructor
 */
global define void Instserver() ``{
    configSetup();
}


/* EOF */
}
