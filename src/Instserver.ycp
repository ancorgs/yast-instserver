/**
 * File:	modules/Instserver.ycp
 * Package:	Configuration of Installation Server
 * Summary:	Installation Server settings, input and output functions
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of Installation Server.
 * Input and output routines.
 */

{

module "Instserver";
textdomain "instserver";

import "Progress";
import "Report";
import "Summary";
import "XML";
import "Popup";
import "Package";
import "Call";
import "Service";
import "SLP";
import "IP";

include "instserver/routines.ycp";


// Is this a service pack?
global boolean is_service_pack = false;

global boolean test = false;

/* Configuration Map */
global map<string, any> Config = $[];

/* All Configurations */
global map<string, map<string, any> > Configs = $[];

/* Server Configuration */
global map ServerSettings = $[];

/* Configuration Repository */
global string Rep = "/etc/YaST2/instserver";

/* config file */
string ConfigFile = Rep + "/instserver.xml";


global string FirstDialog = "summary";


global list<map> products = [];


global list<string> Detected = [];

global boolean standalone = false;

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;



global list<string> to_delete = [];

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean AbortFunction = Modified();

/**
 * Abort function
 * @return boolean
 */
global define boolean Abort() {
    if(AbortFunction != nil)
	return (boolean)eval(AbortFunction);
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}



/**
 * Create links
 */
global list<string> createLinks (string dir, string product, list<string> files)
{
    string shorttgt = sformat("%1/CD%2",  product, 1 );
    list<string> cmds = [];

    foreach(string symlink , files, ``{
	string f = sformat("%1/%2/%3", dir, shorttgt, symlink );

	cmds=add(cmds, sformat("( test -f %1 || test -d %2) &&  pushd %3 && ln -sf %4/%5 && popd ",
			       f,f,dir, shorttgt, symlink));

    });
    cmds=add(cmds, sformat("mkdir -p %1/yast", dir));

    y2debug("cmds: %1", cmds );
    return cmds;
}


/**
 * Create yast directory with ordr/instorder files
 * @param string directory
 * @return booelan 
 */
global boolean createOrderFiles(string dir)
{
    string order_path = sformat("%1/yast/order", dir );
    string instorder_path = sformat("%1/yast/instorder", dir );

    if (SCR::Read(.target.size, order_path) > 0 &&
	SCR::Read(.target.size, instorder_path) > 0 &&
	size(products) == 1 )
    {
	y2debug("order files exist");
	string ofile = (string)SCR::Read(.target.string, order_path );
	list<string> oentries = splitstring(ofile, "\n");
	string iofile = (string)SCR::Read(.target.string, instorder_path );
	list<string> ioentries = splitstring(iofile, "\n");

        // clean empty lines
        oentries=filter(string l, oentries, ``(l!=""));
        ioentries=filter(string l, ioentries, ``(l!=""));

	string proddir = sformat("/%1/CD1", products[0, "name"]:"" );
	if (issubstring(tolower(products[0, "name"]:""), "service-pack" ) || is_service_pack)
	{
	    oentries = prepend( oentries, mergestring([  proddir, proddir ], "\t"));
	    ioentries = (list<string>) union(  (list<string>)[  proddir ], ioentries);
	}
	else
	{
	    oentries = add( oentries, mergestring([  proddir, proddir ], "\t"));
            // FIX: instorder only needs first column of the order file in the right
            // order
	    ioentries = add( ioentries, proddir);
	}
        ioentries = add( ioentries, "");
        oentries = add( oentries, "");

	SCR::Write(.target.string, dir + "/yast/order",  mergestring(oentries, "\n"));
	SCR::Write(.target.string, dir + "/yast/instorder",  mergestring(ioentries, "\n"));
    }
    else if (size(products) > 1 )
    {
        SCR::Execute(.target.mkdir, dir + "/yast");
        // create order
        list<map> order = filter(map p, products, ``(!p["baseproduct"]:false));
        order = (list<map>)union(order, filter(map p, products, ``(p["baseproduct"]:false)));

        y2debug("order: %1", order );

        list<map> instorder = filter(map p, products, ``(p["baseproduct"]:false));
        instorder = (list<map>)union(instorder, filter(map p, products, ``(!p["baseproduct"]:false)));

        // HACK: support sles8 too
        list<map> ul = filter(map u, instorder ,
                ``(issubstring(tolower(u["name"]:""), "unitedlinux")));
        if (size(ul) == 0) {
            instorder = order;
        }
        y2debug("instorder: %1", instorder );

        list<string> file = [];
        foreach (map p, order , ``{
                string proddir = sformat("/%1/CD1", p["name"]:"" );
                file = add(file, mergestring([  proddir, proddir ], "\t"));
                });
        file = add(file , "");
        SCR::Write(.target.string, dir + "/yast/order",  mergestring(file, "\n"));
        file = [];
        foreach (map p, instorder , ``{
                string proddir = sformat("/%1/CD1", p["name"]:"" );
                file = add(file, proddir);
                });
        file = add(file , "");
        SCR::Write(.target.string, dir + "/yast/instorder",  mergestring(file, "\n"));
    }
    products = [];
    return true;
}


/**
  * Mount directory to avoid symlinks
  * @param string directory to bind
  * @param string bind to
  * @return boolean
  */
boolean MountBind( string dir, string ftproot)
{
    y2debug("Calling MountBind with: %1 %2", dir, ftproot );
    list<map> fstab = (list<map>)SCR::Read(.etc.fstab);
    y2debug("fstab: %1", fstab );
    list<map> exists = filter(map f, fstab, ``(f["spec"]:"" == deletechars(dir, " ")));
    y2debug("existing: %1", exists );
    if (size(exists)> 0 )
    {
        return false;
    }
    else
    {
        SCR::Execute(.target.mkdir, ftproot);
        SCR::Execute(.target.mount, [ dir, ftproot], "--bind" );
        map bindfs = $[];
        bindfs = $["file":ftproot, "spec":dir, "freq":1,
        "mntops":"bind", "passno":1, "vfstype":"auto"];
        fstab=add(fstab, bindfs);
        SCR::Write(.etc.fstab, fstab);
    }
    return true;
}


/**
 * Configure service using _auto
 */
boolean ConfigureService(string module_auto, any resource) {
    boolean ret = false;
    ret = (boolean)Call::Function(module_auto, ["Import", resource   ]);
    ret = (boolean)Call::Function(module_auto, ["Write",  resource  ]);
    return ret;
}

/**
 * Read service data using _auto
 */
any ReadServiceSettings(string module_auto) {
    boolean r  = (boolean)Call::Function(module_auto, ["Read"]);
    any ret = Call::Function(module_auto, ["Export"]);

    return ret;
}

/**
 * Setup FTP server
 * @param string inst server root
 * @param string ftp server root
 * @return boolean
 */
global boolean SetupFTP(string dir, string ftproot, string ftpalias) {

    string help = _("The FTP installation server requires an FTP server package. The vsftpd package
will now be installed.
");
    if ( !Package::InstalledAll( [ "xinetd", "vsftpd", "openslp-server" ] ) ) {
        y2debug("some packages are not installed");
    }

    if ( !Package::InstallAll( [ "xinetd", "vsftpd" , "openslp-server"])) {
        y2error("Error while installing packages");
        return false;
    }
    string a = "";
    if (!issubstring(dir, a))
    {
        if (ftpalias != "")
        {
            a = ftproot + "/" + ftpalias;
            SCR::Execute(.target.bash,"mkdir -p " + a);
        }
        y2debug("binding dir");
        MountBind(dir, ftproot);
    } else {
        // FIXME
        y2warning("not implemented");
    }

    y2debug("configuring services");
    map inetdconf =
        $["last_created":0,
    "netd_conf":[
        $["protocol":"tcp", "script":"vsftpd", "server":"/usr/sbin/vsftpd", "service":"ftp"]
        ],
    "netd_service":`xinetd,
    "netd_status":0];

    ConfigureService("inetd_auto", inetdconf);
    Service::Enable("xinetd");
    if (Service::Status("xinetd") == 0 )
        Service::Reload("xinetd");
    else
        Service::Start("xinetd");
    return true;
}

/**
 * Write Apache config
 * @param string state : Yes/No
 * @return void
 */
define void RunSuseConfigApache( boolean enable ) ``{
    string flags = (string) SCR::Read( .sysconfig.apache2.APACHE_SERVER_FLAGS );
    if (!issubstring(flags,"inst_server") && enable)
        SCR::Write( .sysconfig.apache2.APACHE_SERVER_FLAGS, flags + " inst_server" );
    else if (issubstring(flags,"inst_server") && !enable)
        SCR::Write( .sysconfig.apache2.APACHE_SERVER_FLAGS, regexpsub(flags, "(.*)inst_server(.*)", "\1 \2" ) );

    if( !SCR::Write( .sysconfig.apache2, nil ) ) {
        Popup::Error( _("Unable to write /etc/sysconfig/apache2") );
        return;
    }
}


/**
 * Setup HTTP server
 * @param string inst server root
 * @param string alias
 * @return boolean
 */
global boolean SetupHTTP(string dir, string alias) {

    string help = _("The HTTP installation server requires an HTTP server package. The apache2 package
will now be installed.");
     if ( !Package::InstalledAny( [ "apache2" , "openslp-server" ] ) ) {
        y2debug("some packages are not installed");

         if ( !Package::InstallAll( [ "apache2" , "apache2-prefork", "openslp-server" ] ) ) {
            y2error("Error while installing packages");
            return false;
        } 
    }

    if ((integer)SCR::Read(.target.size, "/etc/apache2/conf.d/inst_server.conf.in") > 0 )
    {
        string conf = (string)SCR::Read(.target.string, "/etc/apache2/conf.d/inst_server.conf.in");
        list<string> confline = splitstring(conf, "\n");

        if (findfirstof(alias, "/") != 0 )
            alias = "/" + alias;
        confline = maplist(string line, confline, ``{
                any res = regexpsub(line , "(.*)@ALIAS@(.*)", sformat("\\1%1\\2", alias ));
                res = regexpsub((res!=nil) ?(string)res:line , "(.*)@SERVERDIR@(.*)", sformat("\\1%1\\2", dir ));
                if (res != nil)
                return ((string)res);
                else
                return (line);
                });

        y2debug("conf: %1", confline);

        conf = mergestring(confline, "\n");
        if (!SCR::Write(.target.string, "/etc/apache2/conf.d/inst_server.conf", conf ))
        {
            y2error("Error writing apache2 config file");
        }
    } else {
        return false;
    }
    RunSuseConfigApache(true);

    Service::Enable("apache2");
    if (Service::Status("apache2") == 0 )
        Service::Reload("apache2");
    else
        Service::Start("apache2");
    return true;
}


/**
 * Setup NFS Server
 * @param string directory
 * @param string options
 * @return boolean
 */
global boolean SetupNFS(string dir, string options) {

    map resource = (map)ReadServiceSettings("nfs_server_auto");
    list<map> oldexp = resource["nfs_exports"]:[];
    y2milestone("oldexp: %1", oldexp );

    list oldexists = filter(map e, oldexp, ``(e["mountpoint"]:"" == dir) );
    if (size(oldexists) > 0 ) {
        boolean yesno = Popup::YesNo("Directory is already exported via NFS, 
Leave NFS exports unmodified?");
        if (yesno)
        {
            return true;
        }
        else
        {
            oldexp = filter(map e, oldexp, ``(e["mountpoint"]:"" != dir) );
        }
    }
    list<map> exports = oldexp;
    map nfs = $[];
    nfs["start_nfsserver"] = true;
    list allowed = [];
    if (size(options) == 0 ) {
        options = "*(ro,root_squash,sync)";
    }
    allowed=add(allowed, options);
    map ex = $[];
    ex["allowed"] = allowed;
    ex["mountpoint"] = dir;
    exports=add(exports, ex);
    nfs["nfs_exports"] = exports;

    ConfigureService("nfs_server_auto", nfs);

    Service::Enable("nfsserver");
    if (Service::Status("nfsserver") == 0 )
        Service::Reload("nfsserver");
    else
        Service::Start("nfsserver");
    return true;
}

/*
 * Return the IP address of the local machine	
 * @return string IP Address
 */
global string GetIPAddr()
{
    list<map> ifconfig =(list<map>)SCR::Read(.run.ifconfig);
    ifconfig = filter(map iface, ifconfig, ``( iface["name"]:"" == "eth0"));
    integer ip = ifconfig[0,"value", "inet", "addr"]:0;

    return (IP::ToString(ip));
}

/**
 * Write SLP configuration
 */
global boolean WriteSLPReg (map<string,any> cm) {

    string ip = GetIPAddr();
    string serv = "";
    string regfile =  sformat("YaST-%1.reg",  cm["name"]:"" );
    if (ServerSettings["service"]:`none == `nfs)
    {
        serv =  sformat("service:install.suse:nfs://%1/%2/%3%4,en,65535",
                ip,
                ServerSettings["directory"]:"", cm["name"]:"",
                (cm["dir-type"]:`onedir  == `onedir ) ? "":"/CD1" );
    }
    else if (ServerSettings["service"]:`none == `ftp)
    {
        serv =  sformat("service:install.suse:ftp://%1/%2%3,en,65535", ip,
                cm["name"]:"", (cm["dir-type"]:`onedir  == `onedir ) ? "":"/CD1");
    }
    else if (ServerSettings["service"]:`none == `http)
    {
        serv = sformat("service:install.suse:http://%1/%2/%3%4,en,65535",
                ip,
                ServerSettings["alias"]:"", cm["name"]:"",
                (cm["dir-type"]:`onedir  == `onedir ) ? "":"/CD1");
    }

    map<string, string> attr = $[];
    foreach(string a, ["LABEL", "VERSION", "VENDOR", "DEFAULTBASE", "BASEPRODUCT", "BASEVERSION"], ``{
        if (cm[a]:"" != "" )
        {
            attr[tolower(a)] =  cm[a]:"";
        }
        });

    // Check if the description is already used

    string descr = sformat("%1 ++%2++", cm["LABEL"]:"" , cm["DISTPRODUCT"]:"" );

    string cmd = sformat("grep description  /etc/slp.reg.d/YaST-*.reg | grep -c \"%1\"", descr );
    map bashret = (map)SCR::Execute(.target.bash_output, cmd);
    y2debug("description bashret: %1", bashret);
    if (bashret["exit"]:-1 == 0)
    {
        attr["description"] = sformat("%1  #%2", descr,
                substring(bashret["stdout"]:"", 0 , 1 ) );
    }
    else
    {
        attr["description"] = sformat("%1", descr );
    }
    string machine = "";
    list<string> machines = [];
    foreach(string k, any v, cm, ``{
            if (issubstring(k, "ARCH"))
            {
                machines = (list<string>)union (machines, splitstring((string)v, " ") );
            }
            });
    machines = filter(string m , machines, ``(m!="" && m!="noarch"));
    machines = toset(machines);
    y2debug("machines: %1", machines);
    attr["machine"] = mergestring(machines, ",");
    y2debug("machine: %1", machine);

    boolean ret = SLP::RegFile(serv, attr, regfile );

    return ret;
}



global list<string> DetectMedia() {
    if (ServerSettings["directory"]:"" != "")
    {
        string f = sformat("find %1 -maxdepth 2 -name %2 | grep -v yast",
                ServerSettings["directory"]:"", "content");
        map ret = (map)SCR::Execute (.target.bash_output, f);
        list<string> found = splitstring(ret["stdout"]:"", "\n");
        found = filter(string s, found, ``(s!=""));
        found = filter(string file, found, ``{
                string d = dirname(file);
                string media = sformat("%1/media.1/media", d);
                return (SCR::Read(.target.size, media)!= -1 );
                });
        y2debug("media: %1", found);
        return found;
    }
    else
    {
        return ([]);
    }
}

global define map<string, map> FindAvailable() ``{
    map<string, map> Available = $[];
    foreach(string c, Detected, ``{
            map ret = ReadContentFile(c);
            string d = dirname(c);
            string config_name = basename(d);
            if (ret != $[] && !haskey(Configs, config_name))
            {
            Available[d]= ret;
            }
            });
    return Available;
}


/**
 * Read all instserver settings
 * @return true on success
 */
global boolean Read() {

    /* Instserver read dialog caption */
    string caption = _("Initializing Configuration");

    integer steps = 4;

    integer sl = 1;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Read configuration file"),
	    /* Progress stage 2/2 */
	    _("Look for new source media"),
	], [
	    /* Progress step 1/2 */
	    _("Reading configuration file..."),
	    /* Progress step 2/2 */
	    _("Looking for new source media..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();
    map c = $[];


    if (SCR::Read(.target.size, ConfigFile) != -1 )
    {
        c = XML::XMLToYCPFile(ConfigFile);
    }
    list<map<string, any > > all = c["configurations"]:[];
    ServerSettings = c["servers"]:$[];

    Configs = listmap (map<string, any> i, all, ``{
            string name = i["name"]:"";
            return($[name: i]);
            });
    y2milestone("Configs: %1", Configs);

    if (c["servers"]:$[] == $[])
        FirstDialog = "settings";

    ServerSettings = c["servers"]:$[];

    /* Error message */
    if(false) Report::Error(_("Cannot read the database1."));
    sleep(sl);


    // read current settings
    if(Abort()) return false;
    Progress::NextStage();


    Detected = DetectMedia();

    /* Error message */
    if(false) Report::Error(_("Cannot read current settings."));
    sleep(sl);


    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}



/**
 * Prepare map for writing  into XML
 * @return lists of configurations
 */
define list PrepareConfigs() ``{

    list c = maplist(string k, map v, Configs, ``{
        return(v);
    });
    return (c);
}


/**
 * Write all instserver settings
 * @return true on success
 */
global boolean Write() {

    /* Instserver read dialog caption */
    string caption = _("Saving Installation Server Configuration");

    integer steps = 2;

    integer sl = 1;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    list c = PrepareConfigs();
    map xml = $["configurations": c , "servers": ServerSettings ];
    boolean ret = XML::YCPToXMLFile(`instserver, xml, ConfigFile);

    /* Error message */
    if(false) Report::Error (_("Cannot write settings."));
    sleep(sl);

    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();

    boolean slpreload = false;
    // Remove all SLP files
    /*
    foreach(string cn, map cm, Configs, ``{
            string regfile =  sformat("/etc/slp.reg.d/YaST-%1.reg",  cm["name"]:"" );
            if (SCR::Read(.target.size, regfile) > 0 )
            {
                SCR::Execute(.target.remove, regfile);
            }
         });
         */
    // Create all SLP files
    foreach(string c, to_delete, ``{
       string regfile =  sformat("/etc/slp.reg.d/YaST-%1.reg",  c );
       if (SCR::Read(.target.size, regfile) > 0 )
       {
           slpreload = true;
           SCR::Execute(.target.remove, regfile);
       }
    });

    foreach(string cn, map<string, any> cm, Configs, ``{
            if (cm["slp"]:false)
            {
                string regfile =  sformat("/etc/slp.reg.d/YaST-%1.reg",  cm["name"]:"" );
                if (SCR::Read(.target.size, regfile) < 1 )
                {
                    WriteSLPReg(cm);
		    slpreload = true;
                }
            }
        });


    if (slpreload)
    {
        if (Service::Status("slpd") == 0 )
	    Service::Restart("slpd");
        else
	    Service::Start("slpd");
    }

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    return true;
}


global define void UpdateConfig() ``{
    y2debug("current config: %1", Configs );

    string name = Config["name"]:"";
    string old_name = Config["old_name"]:"";
    if (haskey(Instserver::Configs, old_name) && old_name != "")
    {
        Configs = filter(string k, map<string, any> v, Configs, ``(k!=old_name));
        remove(Config, "old_name");
    }
    if (name!="")
    {
        Configs[name] = Config;
    }
    y2debug("current config: %1", Configs );
    return;
}


/**
 * Create XML Configuration
 * @return void
 */
global define void configSetup()
    ``{
    map doc = $[];
    doc["listEntries"] =
        $[
        ];
    doc["cdataSections"] = [];
    doc["rootElement"] = "instserver";
    doc["systemID"] = "/usr/share/YaST2/dtd/instserver.dtd";
    doc["nameSpace"] = "http://www.suse.com/1.0/yast2ns";
    doc["typeNamespace"] = "http://www.suse.com/1.0/configns";
    XML::xmlCreateDoc(`instserver, doc);
    return;
}


/**
 * Get all instserver settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    return true;
}

/**
 * Dump the instserver settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    return $[];
}




/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    /* Configuration summary text for autoyast */
    string sum = "";
    map<string, map> Available = filter( string d, map avail, FindAvailable(), ``(!haskey(Configs, basename(d))));
    list unconf = maplist(string d, map avail, Available, ``{
            string dir = basename(d);
            return(`item(`id(dir), avail["LABEL"]:"" + "(" + avail["DEFAULTBASE"]:"" + ")" )) ;
            });

    sum = Summary::AddHeader(sum, _("Configured Sources"));
    sum = Summary::OpenList(sum);

    foreach(string name , map cfg, Configs , ``{
            string source = cfg["LABEL"]:"" + "<br><b>Architecture: </b>" + cfg["DEFAULTBASE"]:"";
            sum = Summary::AddListItem(sum, source);
            });
    sum = Summary::CloseList(sum);
    return [ sum, unconf ];
}

/**
 * Create an overview table with all configured data
 * @return table items
 */
global list Overview() {
    y2milestone("Configs: %1", Configs);
    list overview = maplist(string name , map cfg, Configs , ``{
            return(`item(`id(name), name, cfg["PRODUCT"]:"" + " " + cfg["VERSION"]:""));
            });
    return overview;

}


/**
 * Constructor
 */
global define void Instserver() ``{
    configSetup();
}


/* EOF */
}
