/**
 * File:	modules/Instserver.ycp
 * Package:	Configuration of instserver
 * Summary:	Instserver settings, input and output functions
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of instserver.
 * Input and output routines.
 */

{

module "Instserver";
textdomain "instserver";

import "Progress";
import "Report";
import "Summary";
import "XML";
import "Popup";
import "Require";
import "Call";
import "Service";
import "SLP";

include "instserver/routines.ycp";

/* Configuration Map */
global map Config = $[];

/* All Configurations */
global map Configs = $[];

/* Server Configuration */
global map ServerSettings = $[];

/* Configuration Repository */
global string Rep = "/var/lib/YaST2/instserver";

/* config file */
string ConfigFile = Rep + "/instserver.xml";

global string FirstDialog = "summary";


global list Detected = [];



global boolean standalone = true;

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean AbortFunction = Modified();

/**
 * Abort function
 * @return boolean
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
	return (boolean)eval(AbortFunction);
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}


/**
  * Mount directory to avoid symlinks
  * @param string directory to bind
  * @param string bind to
  * @return boolean
  */
boolean MountBind( string dir, string ftproot) {
    y2debug("Calling MountBind with: %1 %2", dir, ftproot );
    list fstab = (list)SCR::Read(.etc.fstab);
    y2debug("fstab: %1", fstab );
    list existing = filter(map f, fstab, ``(f["spec"]:"" == deletechars(dir, " ")));
    y2debug("existing: %1", existing );
    if (size(existing)> 0 )
    {
        return false;
    }
    else
    {
        SCR::Execute(.target.mkdir, ftproot);
        SCR::Execute(.target.mount, [ dir, ftproot], "--bind" );
        map bindfs = $[];
        bindfs = $["file":ftproot, "spec":dir, "freq":1,
        "mntops":"bind", "passno":1, "vfstype":"auto"];
        fstab=add(fstab, bindfs);
        SCR::Write(.etc.fstab, fstab);
    }
    return true;
}


/**
 * Configure service using _auto
 */
boolean ConfigureService(string module_auto, any resource) {
    boolean ret = false;
    ret = (boolean)Call::Function(module_auto, ["Import", resource   ]);
    ret = (boolean)Call::Function(module_auto, ["Write",  resource  ]);
    return ret;
}

/**
 * Read service data using _auto
 */
any ReadServiceSettings(string module_auto) {
    boolean r  = (boolean)Call::Function(module_auto, ["Read"]);
    any ret = Call::Function(module_auto, ["Export"]);

    return ret;
}

/**
 * Setup FTP server
 * @param string inst server root
 * @param string ftp server root
 * @return boolean
 */
global boolean SetupFTP(string dir, string ftproot) {

    string help = _("The FTP Installation Server requires an FTP server package. The vsftpd package
will now be installed.");
    if ( !Require::AreAllPackagesInstalled( [ "xinetd", "vsftpd" ] ) ) {
        y2debug("some packages are not installed");
    }

    if ( !Require::RequireAndConflict( [ "xinetd", "vsftpd" ], [], help ) ) {
        y2error("Error while installing packages");
        return false;
    }
    if (!issubstring(dir, ftproot))
    {
        y2debug("binding dir");
        MountBind(dir, ftproot);
    }

    y2debug("configuring services");
    map inetdconf =
        $["last_created":0,
    "netd_conf":[
        $["protocol":"tcp", "script":"vsftpd", "server":"/usr/sbin/vsftpd", "service":"ftp"]
        ],
    "netd_service":`xinetd,
    "netd_status":0];

    ConfigureService("inetd_auto", inetdconf);
    Service::Enable("xinetd");
    if (Service::Status("xinetd") == 0 )
        Service::Reload("xinetd");
    else
        Service::Start("xinetd");
    return true;
}

/**
 * Write Apache config
 * @param string state : Yes/No
 * @return void
 */
define void RunSuseConfigApache( string state ) ``{
    SCR::Write( .sysconfig.apache.INSTALLATION_SERVER, state );
    if( !SCR::Write( .sysconfig.apache, nil ) ) {
        Popup::Error( _("Unable to write /etc/sysconfig/apache") );
        return;
    }
    if( SCR::Execute( .target.bash, "/sbin/SuSEconfig --module apache" ) != 0 ) {
        Popup::Error( _("'SuSEconfig --module apache' failed.") );
    }
}


/**
 * Setup HTTP server
 * @param string inst server root
 * @param string alias
 * @return boolean
 */
global boolean SetupHTTP(string dir, string alias) {

    string help = _("The HTTP Installation Server requires an HTTP server package. The apache package
will now be installed.");
    if ( !Require::AreAllPackagesInstalled( [ "apache" ] ) ) {
        y2debug("some packages are not installed");
    }

    if ( !Require::RequireAndConflict( [ "apache"  ], [], help ) ) {
        y2error("Error while installing packages");
        return false;
    }

    string conf = (string)SCR::Read(.target.string, "/etc/httpd/inst_server.conf.in");
    list<string> confline = splitstring(conf, "\n");

    confline = maplist(string line, confline, ``{
            any res = regexpsub(line , "(ALIAS_CONFIGLINE)", sformat("Alias %1 %2/", alias , dir ));
            if (res != nil)
                return ((string)res);
            else
                return (line);
            });

    y2debug("conf: %1", confline);

    conf = mergestring(confline, "\n");
    if (!SCR::Write(.target.string, "/etc/httpd/inst_server.conf", conf ))
    {
        y2error("Error writing apache config file");
    }
    RunSuseConfigApache("yes");

    Service::Enable("apache");
    if (Service::Status("apache") == 0 )
        Service::Reload("apache");
    else
        Service::Start("apache");
    return true;
}


/**
 * Setup NFS Server
 * @param string directory
 * @param string options
 * @return boolean
 */
global boolean SetupNFS(string dir, string options) {

    map resource = (map)ReadServiceSettings("nfs_server_auto");
    list<map> oldexp = resource["nfs_exports"]:[];
    y2milestone("oldexp: %1", oldexp );

    list oldexists = filter(map e, oldexp, ``(e["mountpoint"]:"" == dir) );
    if (size(oldexists) > 0 ) {
        boolean yesno = Popup::YesNo("Directory is already exported via NFS, 
Leave NFS exports unmodified?");
        if (yesno)
        {
            return true;
        }
        else
        {
            oldexp = filter(map e, oldexp, ``(e["mountpoint"]:"" != dir) );
        }
    }
    list<map> exports = oldexp;
    map nfs = $[];
    nfs["start_nfsserver"] = true;
    list allowed = [];
    if (size(options) == 0 ) {
        options = "*(ro,root_squash,sync)";
    }
    allowed=add(allowed, options);
    map ex = $[];
    ex["allowed"] = allowed;
    ex["mountpoint"] = dir;
    exports=add(exports, ex);
    nfs["nfs_exports"] = exports;

    ConfigureService("nfs_server_auto", nfs);

    Service::Enable("nfsserver");
    if (Service::Status("nfsserver") == 0 )
        Service::Reload("nfsserver");
    else
        Service::Start("nfsserver");
    return true;
}


global boolean WriteSLPReg (map cm) {

    string serv = "";
    if (ServerSettings["service"]:`none == `nfs)
    {
        serv =  sformat("service:YaST-Source:nfs://$HOSTNAME%1/%2,en,65535", ServerSettings["directory"]:"", cm["name"]:"");
    }
    else if (ServerSettings["service"]:`none == `ftp)
    {
        serv =  sformat("service:YaST-Source:ftp://$HOSTNAME/%1,en,65535",  cm["name"]:"");
    }
    else if (ServerSettings["service"]:`none == `http)
    {
        serv = sformat("service:YaST-Source:http://$HOSTNAME/%1/%2,en,65535", ServerSettings["alias"]:"", cm["name"]:"");
    }

    map attr = $[];
    foreach(string a, ["LABEL", "VERSION", "VENDOR", "DEFAULTBASE", "BASEPRODUCT", "BASEVERSION"], ``{
        attr[tolower(a)] =  cm[a]:"";
        });

    string regfile =  sformat("YaST-%1.reg",  cm["name"]:"" );
    boolean ret = SLP::RegFile(serv, attr, regfile );
    return ret;
}



global list DetectMedia() {
    if (ServerSettings["directory"]:"" != "")
    {
        string f = sformat("find %1 -maxdepth 2 -name %2 | grep -v yast", ServerSettings["directory"]:"", "content");
        map ret = (map)SCR::Execute (.target.bash_output, f);
        list found = splitstring(ret["stdout"]:"", "\n");
        found = filter(string s, found, ``(s!=""));
        found = filter(string file, found, ``{
                string d = dirname(file);
                string media = sformat("%1/media.1/media", d);
                return (SCR::Read(.target.size, media)!= -1 );
                });
        y2debug("media: %1", found);
        return found;
    }
    else
    {
        return ([]);
    }
}

global define map FindAvailable() ``{
    map Available = $[];
    foreach(string c, Detected, ``{
            map ret = ReadContentFile(c);
            string d = dirname(c);
            string config_name = basename(d);
            if (ret != $[] && !haskey(Configs, config_name))
            {
            Available[d]= ret;
            }
            });
    return Available;
}


/**
 * Read all instserver settings
 * @return true on success
 */
global boolean Read() {

    /* Instserver read dialog caption */
    string caption = _("Initializing Configuration");

    integer steps = 4;

    integer sl = 1;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Read Configuration File"),
	    /* Progress stage 2/2 */
	    _("Look for new source media"),
	], [
	    /* Progress step 1/2 */
	    _("Reading configuration file..."),
	    /* Progress step 2/2 */
	    _("Looking for new source media..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();
    map c = $[];


    if (SCR::Read(.target.size, ConfigFile) != -1 )
    {
        c = XML::XMLToYCPFile(ConfigFile);
    }
    list all = c["configurations"]:[];
    ServerSettings = c["servers"]:$[];

    Configs = listmap (map i, all, ``{
            string name = i["name"]:"";
            return($[name: i]);
            });
    y2milestone("Configs: %1", Configs);

    if (c["servers"]:$[] == $[])
        FirstDialog = "server";

    ServerSettings = c["servers"]:$[];

    /* Error message */
    if(false) Report::Error(_("Cannot read the database1."));
    sleep(sl);


    // read current settings
    if(Abort()) return false;
    Progress::NextStage();


    Detected = DetectMedia();

    /* Error message */
    if(false) Report::Error(_("Cannot read current settings."));
    sleep(sl);


    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}



/**
 * Prepare map for writing  into XML
 * @return lists of configurations
 */
define list PrepareConfigs() ``{

    list c = maplist(string k, map v, Configs, ``{
        return(v);
    });
    return (c);
}


/**
 * Write all instserver settings
 * @return true on success
 */
global boolean Write() {

    /* Instserver read dialog caption */
    string caption = _("Saving instserver Configuration");

    integer steps = 2;

    integer sl = 1;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    list c = PrepareConfigs();
    map xml = $["configurations": c , "servers": ServerSettings ];
    boolean ret = XML::YCPToXMLFile(`instserver, xml, ConfigFile);

    /* Error message */
    if(false) Report::Error (_("Cannot write settings."));
    sleep(sl);

    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();

    foreach(string cn, map cm, Configs, ``{
            if (cm["slp"]:false)
                WriteSLPReg(cm);
        });
    /* Error message */
    if(false) Report::Error (_("SuSEconfig script failed."));
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    return true;
}


global define void UpdateConfig() ``{
    y2debug("current config: %1", Configs );
    string name = Config["name"]:"";
    string old_name = Config["old_name"]:"";
    if (haskey(Instserver::Configs, old_name) && old_name != "")
    {
        Configs = filter(string k, map v, Configs, ``(k!=old_name));
        remove(Config, "old_name");
    }
    Configs[name] = Config;
    y2debug("current config: %1", Configs );
    return;
}


/**
 * Create XML Configuration
 * @return void
 */
global define void configSetup()
    ``{
    map doc = $[];
    doc["listEntries"] =
        $[
        ];
    doc["cdataSections"] = [];
    doc["rootElement"] = "instserver";
    doc["systemID"] = "/usr/share/YaST2/dtd/instserver.dtd";
    doc["nameSpace"] = "http://www.suse.com/1.0/yast2ns";
    doc["typeNamespace"] = "http://www.suse.com/1.0/configns";
    XML::xmlCreateDoc(`instserver, doc);
    return;
}


/**
 * Get all instserver settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    return true;
}

/**
 * Dump the instserver settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    return $[];
}




/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    /* Configuration summary text for autoyast */
    string sum = "";
    map Available = filter( string d, map avail, FindAvailable(), ``(!haskey(Configs, basename(d))));
    list unconf = maplist(string d, map avail, Available, ``{
            string dir = basename(d);
            return(`item(`id(dir), avail["LABEL"]:"" + "(" + avail["DEFAULTBASE"]:"" + ")" )) ;
            });

    sum = Summary::AddHeader(sum, _("Configured Sources"));
    sum = Summary::OpenList(sum);

    foreach(string name , map cfg, Configs , ``{
            string source = cfg["LABEL"]:"" + "<br><b>Architecture: </b>" + cfg["DEFAULTBASE"]:"";
            sum = Summary::AddListItem(sum, source);
            });
    sum = Summary::CloseList(sum);
    return [ sum, unconf ];
}

/**
 * Create an overview table with all configured data
 * @return table items
 */
global list Overview() {
    y2milestone("Configs: %1", Configs);
    list overview = maplist(string name , map cfg, Configs , ``{
            return(`item(`id(name), name, cfg["PRODUCT"]:"" + " " + cfg["VERSION"]:""));
            });
    return overview;

}


/**
 * Constructor
 */
global define void Instserver() ``{
    configSetup();
}


/* EOF */
}
