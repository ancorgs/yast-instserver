/**
 * File:	modules/Instserver.ycp
 * Package:	Configuration of instserver
 * Summary:	Instserver settings, input and output functions
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 * Representation of the configuration of instserver.
 * Input and output routines.
 */

{

module "Instserver";
textdomain "instserver";

import "Progress";
import "Report";
import "Summary";
import "XML";
import "Popup";
import "Require";
import "Call";
import "Service";

include "instserver/routines.ycp";

/* Configuration Map */
global map Config = $[];

/* All Configurations */
global map Configs = $[];

/* Server Configuration */
global map ServerSettings = $[];

/* Configuration Repository */
global string Rep = "/var/lib/YaST2/instserver";

/* config file */
string ConfigFile = Rep + "/instserver.xml";

global string FirstDialog = "summary";


global map Available = $[];

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean AbortFunction = Modified();

/**
 * Abort function
 * @return blah blah lahjk
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
	return (boolean)eval(AbortFunction);
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}




boolean MountBind( string dir, string ftproot) {
    list fstab = (list)SCR::Read(.etc.fstab);
    list existing = filter(map f, fstab, ``(f["spec"]:"" == dir));
    if (size(existing)> 0 )
    {
        return false;
    }
    else
    {
        SCR::Execute(.target.mkdir, ftproot);
        SCR::Execute(.target.mount, [ dir, ftproot], "--bind" );
        map bindfs = $[];
        bindfs = $["file":ftproot, "spec":dir, "freq":1,
        "mntops":"bind", "passno":1, "vfstype":"auto"];
        fstab=add(fstab, bindfs);
        SCR::Write(.etc.fstab, fstab);
    }
    return true;
}

boolean ConfigureService(string module_auto, map resource) {
    boolean ret = false;
    ret = (boolean)Call::Function(module_auto, ["Import", resource   ]);
    ret = (boolean)Call::Function(module_auto, ["Write",  resource  ]);
    return ret;
}

global boolean SetupFTP(string dir, string ftproot) {

    string help = _("The FTP Installation Server requires an FTP server. The vsftpd package
will now be installed.");
    if ( !Require::AreAllPackagesInstalled( [ "xinetd", "vsftpd" ] ) ) {
        y2debug("some packages are not installed");
    }

    if ( !Require::RequireAndConflict( [ "xinetd", "vsftpd" ], [], help ) ) {
        y2error("Error while installing packages");
        return false;
    }
    if (!issubstring(dir, ftproot))
    {
        y2debug("binding dir");
        MountBind(dir, ftproot);
    }

    y2debug("configuring services");
    map inetdconf =
        $["last_created":0,
    "netd_conf":[
        $["protocol":"tcp", "script":"vsftpd", "server":"/usr/sbin/vsftpd", "service":"ftp"]
        ],
    "netd_service":`xinetd,
    "netd_status":0];

    ConfigureService("inetd_auto", inetdconf);
    Service::Enable("xinetd");
    if (Service::Status("xinetd") == 0 )
        Service::Reload("xinetd");
    else
        Service::Start("xinetd");
    return true;
}



/**
 * Setup NFS Server
 * @param string directory
 * @param string options
 * @return boolean
 */
global boolean SetupNFS(string dir, string options) {

    import "NfsServer";
    boolean ret = false;
    NfsServer::Read();
    list<map> oldexp = NfsServer::exports;

    list oldexists = filter(map e, oldexp, ``(e["mountpoint"]:"" == dir) );
    if (size(oldexists) > 0 ) {
        boolean yesno = Popup::YesNo("Directory is already exported via NFS, continue anyway?");
        if (!yesno)
            return false;
    }
    list<map> exports = oldexp;
    map nfs = $[];
    nfs["start_nfsserver"] = true;
    list allowed = [];
    if (size(options) == 0 ) {
        // FIXME: Calculate mask and allow clients in the same network.
        options = "*(ro,root_squash,sync)";
    }
    allowed=add(allowed, options);
    map ex = $[];
    ex["allowed"] = allowed;
    ex["mountpoint"] = dir;
    exports=add(exports, ex);
    nfs["nfs_exports"] = exports;

    NfsServer::Import(nfs);
    Progress::off();
    NfsServer::write_only = true;
    ret = NfsServer::Write();
    Progress::on();
    Service::Enable("nfsserver");
    if (Service::Status("nfsserver") == 0 )
        Service::Reload("nfsserver");
    else
        Service::Start("nfsserver");
    return ret;
}


global boolean WriteSLPReg (map cm) {

    list<string> slp = [];
    if (ServerSettings["service"]:`none == `nfs)
    {
        slp=add(slp, sformat("service:YaST-Source:nfs://$HOSTNAME%1/%2,en,65535", ServerSettings["directory"]:"", cm["name"]:""));
    }
    else if (ServerSettings["service"]:`none == `ftp)
    {
        slp=add(slp, sformat("service:YaST-Source:ftp://$HOSTNAME/%1,en,65535",  cm["name"]:""));
    }
    else if (ServerSettings["service"]:`none == `http)
    {
        slp=add(slp, sformat("service:YaST-Source:http://$HOSTNAME/%1/%2,en,65535", ServerSettings["alias"]:"", cm["name"]:""));
    }

    foreach(string a, ["LABEL", "VERSION", "VENDOR", "DEFAULTBASE", "BASEPRODUCT", "BASEVERSION"], ``{
        slp=add(slp, sformat("%1=%2", tolower(a), cm[a]:"" ));
        });

    string all = mergestring(slp, "\n");
    SCR::Execute(.target.bash,  sformat("touch /etc/slp.reg.d/YaST-%1.reg",  cm["name"]:"" ));
    boolean ret =(boolean) SCR::Write(.target.string,    sformat("/etc/slp.reg.d/YaST-%1.reg",  cm["name"]:"" ), all);
    return ret;
}



global list DetectMedia() {
    if (ServerSettings["directory"]:"" != "")
    {
        string f = sformat("find %1 -maxdepth 2 -name %2 | grep -v yast", ServerSettings["directory"]:"", "content");
        map ret = (map)SCR::Execute (.target.bash_output, f);
        list found = splitstring(ret["stdout"]:"", "\n");
        found = filter(string s, found, ``(s!=""));
        found = filter(string file, found, ``{
                string d = dirname(file);
                string media = sformat("%1/media.1/media", d);
                return (SCR::Read(.target.size, media)!= -1 );
                });
        y2debug("media: %1", found);
        return found;
    }
    else
    {
        return ([]);
    }
}



/**
 * Read all instserver settings
 * @return true on success
 */
global boolean Read() {

    /* Instserver read dialog caption */
    string caption = _("Initializing Configuration");

    integer steps = 4;

    integer sl = 1;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Read Configuration File"),
	    /* Progress stage 2/2 */
	    _("Look for new source media"),
	], [
	    /* Progress step 1/2 */
	    _("Reading configuration file..."),
	    /* Progress step 2/2 */
	    _("Looking for new source media..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();
    map c = $[];


    if (SCR::Read(.target.size, ConfigFile) != -1 )
    {
        c = XML::XMLToYCPFile(ConfigFile);
    }
    list all = c["configurations"]:[];
    ServerSettings = c["servers"]:$[];

    Configs = listmap (map i, all, ``{
            string name = i["name"]:"";
            return($[name: i]);
            });
    y2milestone("Configs: %1", Configs);

    if (c["servers"]:$[] == $[])
        FirstDialog = "server";

    ServerSettings = c["servers"]:$[];

    /* Error message */
    if(false) Report::Error(_("Cannot read the database1."));
    sleep(sl);


    // read current settings
    if(Abort()) return false;
    Progress::NextStage();


    list media = DetectMedia();
    foreach(string c, media, ``{
            map ret = ReadContentFile(c);
            string d = dirname(c);
            string config_name = basename(d);
            if (ret != $[] && !haskey(Configs, config_name))
            {
            Available[d]= ret;
            }
            });

    /* Error message */
    if(false) Report::Error(_("Cannot read current settings."));
    sleep(sl);


    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}



/**
 * Prepare map for writing  into XML
 * @return lists of configurations
 */
define list PrepareConfigs() ``{

    list c = maplist(string k, map v, Configs, ``{
        return(v);
    });
    return (c);
}


/**
 * Write all instserver settings
 * @return true on success
 */
global boolean Write() {

    /* Instserver read dialog caption */
    string caption = _("Saving instserver Configuration");

    integer steps = 2;

    integer sl = 1;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Run SuSEconfig")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Running SuSEconfig..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    list c = PrepareConfigs();
    map xml = $["configurations": c , "servers": ServerSettings ];
    boolean ret = XML::YCPToXMLFile(`instserver, xml, ConfigFile);

    /* Error message */
    if(false) Report::Error (_("Cannot write settings."));
    sleep(sl);

    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();

    foreach(string cn, map cm, Configs, ``{
            if (cm["slp"]:false)
                WriteSLPReg(cm);
        });
    /* Error message */
    if(false) Report::Error (_("SuSEconfig script failed."));
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    return true;
}



/**
 * Create XML Configuration
 * @return void
 */
global define void configSetup()
    ``{
    map doc = $[];
    doc["listEntries"] =
        $[
        ];
    doc["cdataSections"] = [];
    doc["rootElement"] = "instserver";
    doc["systemID"] = "/usr/share/YaST2/dtd/instserver.dtd";
    doc["nameSpace"] = "http://www.suse.com/1.0/yast2ns";
    doc["typeNamespace"] = "http://www.suse.com/1.0/configns";
    XML::xmlCreateDoc(`instserver, doc);
    return;
}


/**
 * Get all instserver settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    return true;
}

/**
 * Dump the instserver settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    return $[];
}




/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    /* Configuration summary text for autoyast */
    string sum = "";
    Available = filter( string d, map avail, Available, ``(!haskey(Configs, basename(d))));
    list unconf = maplist(string d, map avail, Available, ``{
            string dir = basename(d);
            return(`item(`id(dir), avail["LABEL"]:"" + "(" + avail["DEFAULTBASE"]:"" + ")" )) ;
            });

    sum = Summary::AddHeader(sum, _("Configured Sources"));
    sum = Summary::OpenList(sum);
    foreach(string name , map cfg, Configs , ``{
            string source = cfg["LABEL"]:"" + "<br><b>Architecture: </b>" + cfg["DEFAULTBASE"]:"";
            sum = Summary::AddListItem(sum, source);
            });
    sum = Summary::CloseList(sum);
    return [ sum, unconf ];
}

/**
 * Create an overview table with all configured data
 * @return table items
 */
global list Overview() {
    y2milestone("Configs: %1", Configs);
    list overview = maplist(string name , map cfg, Configs , ``{
            return(`item(`id(name), name, cfg["PRODUCT"]:"" + " " + cfg["VERSION"]:""));
            });
    return overview;

}


/**
 * Constructor
 */
global define void Instserver() ``{
    configSetup();
}


/* EOF */
}
