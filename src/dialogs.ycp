/**
 * File:	include/instserver/dialogs.ycp
 * Package:	Configuration of instserver
 * Summary:	Dialogs definitions
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */

{

    textdomain "instserver";

    import "Installation";
    import "Label";
    import "Popup";
    import "Wizard";
    import "Instserver";

    include "instserver/helps.ycp";
    include "instserver/routines.ycp";



    /**
     * CD Popup
     * @param string popup message
     * @param boolean true if ISO
     * @return any
     */
    any CDPopup (string msg, boolean iso)
	{
	    if (iso)
	    {
		any f = UI::AskForExistingFile( Instserver::ServerSettings["iso-dir"]:"", "*.iso", msg );
		y2milestone("file: %1", f);
		if (f!= nil)
		{
		    return f;
		}
		else
		{
		    return "";
		}
	    }
	    else
	    {
		symbol pop =  Popup::AnyQuestion3(_("Change Media"),
						  msg,
						  Label::ContinueButton(),
						  _("Ski&p"),
						  Label::CancelButton(),
						  `focus_yes );
		if (pop == `retry)
		{
		    return `abort;
		}
		else if (pop == `no)
		{
		    y2debug("skipping media");
		    return `skip;
		}
	    }
	}

    string LinkTarget(string source) {
	string ret = "";

	string command = "ls -l " + source;
	map res = (map)SCR::Execute(.target.bash_output, command);
	list<string> out = splitstring(res["stdout"]:"", "\n");

	if (size(out) > 0)
	{
	    string line = out[0]:"";

	    ret = regexpsub(line, "^l.* -> (.*)", "\\1");
	}

	y2milestone("Target of %1: %2", source, ret);

	return ret;
    }

    boolean IsBaseProduct(map content, string cont_file) {
	boolean ret = false;
	map basecontent = ReadContentFile(cont_file);

	y2milestone("using content file: %1", cont_file);
	y2milestone("content: %1", content);
	y2milestone("basecontent: %1", basecontent);

	if ((tolower(content["BASEPRODUCT"]:"") == tolower(basecontent["BASEPRODUCT"]:"")
	    && content["BASEVERSION"]:"" == basecontent["BASEVERSION"]:"")
	    // or it's a service pack for maintained product (e.g. NLD)
	    // compare BASEPRODUCT and PRODUCT in that case
	    || (!haskey(basecontent, "BASEPRODUCT") && !haskey(basecontent, "BASEVERSION") &&
		tolower(content["BASEPRODUCT"]:"") == tolower(basecontent["PRODUCT"]:"")
		&& content["BASEVERSION"]:"" == basecontent["VERSION"]:"" )
	)
	{
	    // Same base product => OK
	    ret = true;
	    y2milestone("found matching base product");
	}

	return ret;
    }

    /**
     * Copy CDs to local disk
     * @param string directory
     * @param symbol source type
     * @param boolean true if copying using ISO files
     * @param boolean prompt for additional CDs.
     * @return any
     */
    any CopyCDs( string dir, symbol stype, boolean iso, boolean promptmore, string cddrive)
	{

	    // free mount point
	    SCR::Execute (.target.umount, Installation::sourcedir);


	    string default_device = cddrive;
	    string mount_options = "";
	    any result = nil;


	    // CD is mounted. Check contents.
	    string cdpath = Installation::sourcedir;

	    integer current_cd = 1;
	    integer total_cds = 1;
	    boolean standalone = true;
	    boolean standalone_product = true;
	    boolean baseproduct = false;
	    string base = "";
	    string basever = "";
            string prompt_string = "";
            string prompt_version = "";
            integer prompt_totalcds = 0;
            string medianame = "";
            boolean doublesided = false;
            list medianames = [];
            boolean failed = false;
            boolean cds_copied = false;

            string media_id = "";

            boolean restart = false;

	    symbol pop = `none;

	    // content file at first CD must be preserved (#171157)
	    string content_first_CD	= "";

            // Fix for mounting ISO images over NFS
	    if (iso)
	    {
		mount_options = "-oloop,ro ";
	    } 
            else
            {
		mount_options = "";
            }

	    // Loop for all CDs
	    while (true)
	    {
		string msg = "";
		if (!baseproduct && standalone && size(medianames) == 0)
		{
		    // %1 is the current cd number
		    if (!iso)
			msg = sformat(_("Insert CD %1 then press continue."), current_cd );
		    else
			msg = sformat(_("Select ISO image %1 then press continue."), current_cd );
		}
		else
		{
		    // %2 is the product name and version
                    string cd_prompt = _("Insert CD %1 of %2.");
                    string iso_prompt = _("Select ISO image %1 of %2.");
                    integer prompt_for_cd = 0;

                    if (promptmore  || (!standalone && !baseproduct) && !restart)
                    {
                        prompt_for_cd = current_cd;
                    }
                    else
                    {
                        prompt_for_cd = prompt_totalcds + current_cd;
                    }

		    if (!iso)
                    {
                        if (size(medianames) == 0)
                        {
			    msg = sformat(cd_prompt, prompt_for_cd,
                                    prompt_string );
                        }
                        else
                        {
                            string m = "";
                            y2milestone("medianames: %1, totalcds: %2",
                                    size(medianames), total_cds );
                            if (size(medianames) > 1 )
                            {
                                y2milestone("all media names available");
                                m = medianames[prompt_for_cd - 1]:"";
                            }
                            else
                            {
                                prompt_string =
                                    substring(regexpsub(medianames[0]:"",
                                                "(.*)CD.", "\\1CD%1"), 7,
                                            size(medianames[0]:""));
                                m = sformat(prompt_string, prompt_for_cd);
                            }
                            msg =sformat("Insert\n%1", m);
                        }
                    }
		    else
                    {
                        if (size(medianames) == 0)
                        {
			    msg = sformat(iso_prompt, prompt_for_cd,
                                    prompt_string );
                        }
                        else
                        {
                            string m = "";
                            y2milestone("medianames: %1, totalcds: %2",
                                    size(medianames), total_cds );
                            if (size(medianames) > 1 )
                            {
                                y2milestone("all media names available");
                                m = medianames[prompt_for_cd - 1]:"";
                            }
                            else
                            {
                                prompt_string =
                                    regexpsub(medianames[0]:"",
                                                "(.*)CD.", "\\1CD%1");
                                y2debug("prompt string: %1)", prompt_string);
                                m = sformat(prompt_string, prompt_for_cd);
                            }
                            msg = sformat("Select %1", m);
                        }
                    }
		}


		if (iso)
		{
		    default_device = (string)CDPopup(msg, iso);
		    if  ( default_device == "")
		    {
                        y2debug("total_cds: %1, current_cd: %2", total_cds, current_cd);
			if (total_cds == current_cd)
			{
                            failed = !cds_copied;
			    break;
			}
			else
			{
			    current_cd = current_cd + 1;
			    continue;
			}
		    }
		}
		else
		{
		    pop = (symbol)CDPopup(msg, iso);
		    if (pop == `skip)
		    {
			if (total_cds == current_cd )
			{
			    break;
			}
			else
			{
			    current_cd = current_cd + 1;
			    continue;
			}
		    }
		    else if ( pop == `abort)
		    {
			return `abort;
		    }
		}

		// try to mount device
		if (SCR::Execute (.target.mount, [ default_device, Installation::sourcedir], mount_options) == false)
		{
		    // cant mount /dev/cdrom popup
		    y2error("mount faild");
		    continue;
		}
		y2debug("mounted cdrom");

		list<string> media = ReadMediaFile( sformat("%1/media.%2/media", cdpath, current_cd ));
		y2debug("media: %1", media);
		map content = $[];

		if (size(media) == 0  || (media_id != media[1]:"" && media_id!="") )
		{
		    y2debug("wrong CD or non suse CD");
		    SCR::Execute (.target.umount, Installation::sourcedir);
		    continue;
		}
		else
		{
		    content = ReadContentFile(cdpath + "/content");
                    y2debug("Content file: %1", content);
		    // don't rewrite the already read content file,
		    // content file from CORE9 would rewrite already read file from SLES9
		    if (current_cd == 1 && content_first_CD == "")
		    {
			y2milestone("Reading content file %1", cdpath + "/content");
			content_first_CD = (string) SCR::Read (.target.string, cdpath + "/content");
			y2debug("content file: %1", content_first_CD);
		    }
		    if (media[2]:"" != "" && media[2]:"" != "doublesided")
		    {
			total_cds = tointeger(media[2]:"-1");
                        media_id = media[1]:"";
			y2debug("total cds expected: %1", total_cds);
		    }

                    y2debug("base: %1 basever: %2", base, basever );

                    // Bug 47599: CD2 of SP1 not copied
		    if (content["PRODUCT"]:"dummy" != base && content["VERSION"]:"dummy" != basever  && !standalone)
		    {
                        /*
                         *  Check if this CD set is based on the base product (CORE)
                         */
                        if ( content["BASEPRODUCT"]:"dummy" != base && content["BASEVERSION"]:"dummy" != basever )
                        {
			    SCR::Execute (.target.umount, Installation::sourcedir);
			    continue;
                        }
		    }

                    foreach(string m, media, ``{
                            if (m == "doublesided")
                            doublesided = true;

                            if (substring(m, 0, 5 ) == "MEDIA" )
                            {
                            if (doublesided)
                                medianame = regexpsub(m, "(.*)SIDE A(.*)", "\\1SIDE %1\\2");
                            else
                                medianame = regexpsub(m, "(.*)CD.", "\\1CD%1");

                            medianames=add(medianames, substring(m,7,
                                    size(m)));
                            }
                            });
                    y2milestone("medianames: %1", medianames);
		}


		string distprod = content["LABEL"]:"";
                string flags = content["FLAGS"]:"";
                list<string> flaglist = splitstring(flags, " ");

                // Detect SP
                if (contains(flaglist, "SP"))
                {
                    Instserver::is_service_pack = true;
                    y2milestone("Service Pack detected..");
                } else {
                    Instserver::is_service_pack = false;
                }


		list<string> l = splitstring(distprod, " ");
		distprod = mergestring(l, "-");
		string tgt = sformat("%1/%2/CD%3", dir, distprod, current_cd );
		y2debug("tgt: %1", tgt );

		string shorttgt = sformat("%1/CD%2",  distprod, current_cd );
		y2debug("shorttgt: %1", shorttgt );

		list<string> cmds = [];

		// Copy stuff here.
		// Now, we check if this product on the CD is based on some other product. If
		// yes, then it will be copied into  a sub-directory and not in the requested
		// root.

		// This product is based on some other product
		if ( tolower(content["BASEPRODUCT"]:"") != "" && content["BASEVERSION"]:"" != "")
		{
		    y2milestone("products: %1", Instserver::products);
		    y2milestone("product require base product: %1, version: %2", content["BASEPRODUCT"]:"", content["BASEVERSION"]:"");

		    boolean found = false;
		    foreach(map prod, Instserver::products, {
			    if (!found)
			    {
				string cont_file = dir + "/" + prod["name"]:"" + "/content";
				if (SCR::Read(.target.size, cont_file) < 0)
				{
				    cont_file = dir + "/" + prod["name"]:"" + "/CD1/content";
				}

				if (IsBaseProduct(content, cont_file)) {
				    found = true;
				}
			    }
			}
		    );

		    if (!found)
		    {
			// check also subdirectories
			string cmd = sformat("cd %1; find -maxdepth 1 -type d", Installation::sourcedir + "/yast");
			map out = (map)SCR::Execute(.target.bash_output, cmd);

			list<string> dirs = splitstring(out["stdout"]:"", "\n");

			// remove unusable items
			dirs = filter(string d, dirs, {return d != "." && d != "";});
			y2milestone("found product subdirectories: %1", dirs);

			foreach(string d, dirs, {
				string cont_file = Installation::sourcedir + "/yast/" + d + "/content";

				if (IsBaseProduct(content, cont_file)) {
				    found = true;
				}
			    }
			);
		    }

		    if (!found)
		    {
			// try to search in the base directory (NLD9 workaround)
			string cont_file = Installation::sourcedir + "/content";

			if (IsBaseProduct(content, cont_file)) {
			    found = true;
			    y2milestone("Base product has been found in the base direcory (file %1)", cont_file);
			}
		    }

		    y2milestone("products; %1", Instserver::products);

		    if (!found)
		    {
			// add-on medium (e.g. service pack) doesn't match configured source
			Report::LongError(sformat(_("The medium requires product %1, which is not provided
by the current installation source.

Select the base product medium first."), content["BASEPRODUCT"]:""));
			media_id = "";
			medianames = [];
			continue;
		    }

		    base = content["BASEPRODUCT"]:""; // i.e. SUSE CORE
		    basever = content["BASEVERSION"]:""; // i.e. 9

		    // its not standalone
		    standalone = false;
		    // remember for the finalizing
		    standalone_product = false;

		    // and its not a base product
		    baseproduct = false;

                    // No media names, so we have to create the string for media request
                    if (size(medianames) == 0)
                    {
                        prompt_string = content["LABEL"]:"";
                        prompt_version = content["VERSION"]:"";
                    }
                    else
                    {
                        prompt_version = "";
                    }

                    prompt_totalcds = total_cds;

		    if ( current_cd == 1 )
		    {
			map proddata = $["standalone": false, "baseproduct": false , "name": distprod , "SP": Instserver::is_service_pack ];
			Instserver::products = add(Instserver::products, proddata );
		    }

		    // Create product dir
		    SCR::Execute(.target.mkdir, tgt );
		    y2debug("config=%1, products=%2", Instserver::Config,
			    Instserver::products);

		}
		else if (content["PRODUCT"]:"dummy" == base && content["VERSION"]:"dummy" == basever )
		{
		    if ( current_cd == 1 )
		    {
			map proddata = $["standalone": true, "baseproduct": true , "name": distprod, "SP": Instserver::is_service_pack ];
			Instserver::products = add(Instserver::products, proddata );
		    }
		    standalone = true;
		    baseproduct = true;
		    SCR::Execute(.target.mkdir, tgt );
		    y2debug("config=%1, products=%2", Instserver::Config,
			    Instserver::products);
		}
		else
		{
		    if ( current_cd == 1 )
		    {
			map proddata = $["standalone": true, "baseproduct": true , "name": distprod, "SP": Instserver::is_service_pack ];
			Instserver::products = add(Instserver::products, proddata );
		    }
		    standalone = true;
		    baseproduct = true;
                    if (size(medianames) == 0)
                    {
                        prompt_string = content["LABEL"]:"";
                        prompt_version = content["VERSION"]:"";
                    }
                    else
                    {
                        prompt_version = "";
                    }
		    // else, we create CD1, CD2, etc.
		    if (stype == `onedir)
			tgt = sformat("%1/", dir);
		    else
			tgt = sformat("%1/CD%2", dir, current_cd );
		    y2debug("tgt: %1", tgt );
		    SCR::Execute(.target.mkdir, tgt);
		    y2debug("config=%1, products=%2", Instserver::Config,
			    Instserver::products);
		}

		Popup::ShowFeedback(_("Copying CD contents to local directory"), _("This may take a while..."));

		// Do actual copying of data
		if (Instserver::test)
		{
		    cmds = add(cmds, sformat("cp -pR %1/media.%2 %3", cdpath,
					     current_cd, tgt) );
		    cmds = add(cmds, sformat("cp  %1/content %2", cdpath,
					     tgt));
		}
		else
		{
                    cmds = add(cmds, sformat("cd %1 && tar cf - . | (cd %2  && tar xBf -)", cdpath,  tgt) );
		}


		list<string> files= [];
		// Link files
		if (!standalone && current_cd == 1)
		{
		    if (promptmore)
		    {
			files = ["driverupdate", "linux"];
		    }
		    else
		    {
			files = ["control.xml", "content", "media.1" , "boot"];
		    }
		    cmds = (list<string>)union(cmds, Instserver::createLinks( dir, distprod, files ) );
		}

		if (size(cmds) > 0 )
		{
		    boolean aborted = false;

		    foreach(string cmd , cmds, ``{
                        y2milestone("executing command: %1", cmd );

                        integer res = (integer)SCR::Execute(.target.bash, cmd);

			if (res != 0)
			{
			    y2milestone("aborting: command %1 failed, exit=%2", cmd, res);

			    // close the progress popup
			    Popup::ClearFeedback();

			    // TODO: report more details (stderr)
			    Report::Error(_("Error while moving installation source content."));
			    aborted = true;

			    break;
			}
		    });

		    if (aborted)
		    {
			// unmount the source
			SCR::Execute (.target.umount, Installation::sourcedir);
			return `abort;
		    }

		    cmds = [];
                    cds_copied= true;
		}

		// check if there is a new rescue image on the first additional CD
		if (promptmore && current_cd == 1 && SCR::Read(.target.size, tgt + "/boot") > 0 && dir + "/" != tgt)
		{
		    y2milestone("Found new 'boot' directory");

		    // workaround for flat directory structure (NLD9) - preserve the original content
		    string move = sformat("cd %1; test -d boot -a ! -L boot && mv -b boot boot.old && ln -s boot.old boot", dir);
		    SCR::Execute(.target.bash, move);

		    // remember the old "root" file (parse the link)
		    string linktgt = LinkTarget(dir + "/boot");
		    y2milestone("link target: %1", linktgt);

		    // remove the old "boot" link
		    SCR::Execute(.target.bash, sformat("rm -rf %1/boot", dir));

		    // if there are "root" and "rescue" images both then just create a new link
		    if (SCR::Read(.target.size, tgt + "/boot/rescue") > 0 && SCR::Read(.target.size, tgt + "/boot/root") > 0)
		    {
			files = [ "boot" ];
			cmds = (list<string>)union(cmds, Instserver::createLinks( dir, distprod, files ) );
			foreach(string cmd , cmds, ``{
			    y2debug("executing command: %1", cmd );
			    SCR::Execute(.target.bash, cmd);
			});
			cmds = [];
		    }
		    else
		    {
			string mkdir = sformat("mkdir %1/boot", dir);
			SCR::Execute(.target.bash, mkdir);

			string relprod = substring(tgt, size(dir) + 1);
			y2milestone("relative target: %1", relprod);

			// link the new content there (link every file/directory)
			string linkcommand = sformat("cd %1/boot; ln -s ../%2/boot/* .", dir, relprod);
			SCR::Execute(.target.bash, linkcommand);

			// add missing liks from the original product
			linkcommand = sformat("cd %1/boot; ln -s ../%2/* .", dir, linktgt);
			SCR::Execute(.target.bash, linkcommand);

			// recreate the index file
			SCR::Execute(.target.bash, sformat("rm -f %1/boot/directory.yast; cd %1/boot; ls | grep -v -e '^\\.$' -e '^\\.\\.$' > %1/boot/directory.yast", dir));
		    }
		}


		Popup::ClearFeedback();

		SCR::Execute (.target.umount, Installation::sourcedir);

		if (total_cds == current_cd && !standalone && !baseproduct &&
                        !promptmore)
		{
                    y2milestone("Restarting media counter...");
                    restart = true;
		    current_cd = 1;
                    media_id = "";
                    if (size(medianames) == 0)
                    {
                        prompt_string = base;
                        prompt_version = basever;
                    }
		}
		else if ( total_cds == current_cd && ( standalone || baseproduct) )
		{
		    break;
		}
		else if ( total_cds == current_cd && promptmore )
		{
		    break;
		}
		else
		{
		    current_cd = current_cd + 1;
                    y2debug("next cd: %1", current_cd );
		}
		Instserver::standalone = standalone;
	    }
            if (failed)
            {
                return `abort;
            }

	    if (content_first_CD != "")
	    {
		y2milestone ("writing content file from the 1st CD...");
		SCR::Execute (.target.remove, dir + "/content");
		SCR::Write (.target.string, dir + "/content", content_first_CD);
	    }

	    y2milestone ("creating new root directory.yast....");
	    SCR::Execute(.target.bash, sformat("rm -f %1/directory.yast; cd %1; ls -p | grep -v -e '^\\.$' -e '^\\.\\.$' -e 'directory.yast' > %1/directory.yast", dir));

	    y2milestone("standalone_product: %1", standalone_product);

	    // refresh MD5SUMS only when it's a standalone product and number of CDs > 1
	    if (standalone_product && total_cds > 1)
	    {
		// recreate MD5SUM files
		map out = (map) SCR::Execute(.target.bash_output, sformat ("find %1 -type f -name MD5SUMS", dir));
		foreach (string file, splitstring(out["stdout"]:"", "\n"), {
		    if (file != "")
		    {
			string md5dir = substring (file,0,search(file,"/MD5SUMS"));
			// don't change MD5SUMS in product description directory,
			// SHA1 sum of the file is in _signed_ content file
			if (md5dir == nil || md5dir == "" || issubstring(file, "/setup/descr")) return;

			SCR::Execute (.target.remove, file);

			string command = sformat("cd %1; md5sum * > MD5SUMS", md5dir);
			y2milestone("Command: %1", command);
			SCR::Execute (.target.bash, command, $["LANG" : "C"]);
		    }
		});
	    }

	    return `next;
	}

    define list<term> CDdevices() {
	list<map> cds = (list<map>)SCR::Read(.probe.cdrom);
	list<term> ret = [];

	if (cds != nil)
	{
	    foreach(map cd, cds, {
		    string dev = cd["dev_name"]:"";
		    string model = cd["model"]:"";

		    if (dev != nil && dev != "" && model != nil)
		    {
			ret = add(ret, `item(`id(dev), model + sformat(" (%1)", dev)));
		    }
		}
	    );
	}

	return ret;
    }

    /**
     * Source configuration dialog
     * @return dialog result
     */
    any MediaDialog () {

        /* Instserver configuration dialog caption */
        string caption = _("Source Configuration");

        string isodir = Instserver::ServerSettings["iso-dir"]:"";
	list<term> cddevs = CDdevices();
        boolean iso = (size(cddevs) == 0);

        /* Instserver configure1 dialog contents */
        term contents =
            `HVSquash(
		      `VBox(
			    `RadioButtonGroup(`id(`rbg),
				`VBox(
				    `Left(`RadioButton(`id(`disk), `opt(`notify),  _("Read &CD or DVD Medium"), iso == false )),
				     `HBox(
					    `HSpacing(3),
					    `ComboBox(`id(`drive), _("Data &Source"), cddevs),
					    `HStretch()
				     ),
				    `VSpacing(1),
				    `Left(`RadioButton(`id(`iso), `opt(`notify),  _("Use &ISO Images"), iso == true))
				)
			    ),
			    `VSquash(
				     `HBox(
					    `HSpacing(3),
					    `TextEntry(`id(`isodir),  _("Di&rectory with CD Images:"), isodir),
					    `VBox(
						 `VSpacing(),
						 `Bottom(`PushButton(`id(`select_dir), _("Select &Directory")))
						 )
					   )
				     )
		      )
	    );

	Wizard::SetContentsButtons(caption, contents, HELPS["initial2"]:"",
				   Label::BackButton(), Label::NextButton());

	UI::ChangeWidget(`id(`isodir), `Enabled, iso);
	UI::ChangeWidget(`id(`select_dir), `Enabled, iso);

	// disable CD widgets when there is no drive detected
	if (size(cddevs) == 0)
	{
	    UI::ChangeWidget(`id(`disk), `Enabled, false);
	    UI::ChangeWidget(`id(`drive), `Enabled, false);
	}

	any ret = nil;
	while(true) {
	    ret = UI::UserInput();

	    /* abort? */
	    if (ret == `abort || ret == `cancel) {
		if (ReallyAbort()) break;
		else continue;
	    }
	    else if(ret == `back ) {
		break;
	    }
	    else if (ret == `disk || ret == `iso)
	    {
		iso = (boolean)UI::QueryWidget(`id(`iso) , `Value);
		UI::ChangeWidget(`id(`isodir), `Enabled, iso);
		UI::ChangeWidget(`id(`select_dir), `Enabled, iso);
		UI::ChangeWidget(`id(`drive), `Enabled, !iso);
	    }
	    else if (ret == `select_dir)
	    {
		any new_dir = UI::AskForExistingDirectory( isodir, _("Select Directory"));
		if (new_dir != nil)
		{
		    UI::ChangeWidget(`id(`isodir), `Value, (string) new_dir);
		}
		continue;
	    }
	    else if (ret == `next)
	    {
		boolean iso = (boolean)UI::QueryWidget(`id(`iso), `Value);
		string dir = Instserver::Config["directory"]:"";
		string target = Instserver::ServerSettings["directory"]:"" + "/" + dir;

		if (dir == "")
		{
		    Popup::Error(_("Installation server name missing."));
		    continue;
		}

		Instserver::ServerSettings["iso-dir"] = (string)UI::QueryWidget(`id(`isodir), `Value);

		string selecteddrive = (string)UI::QueryWidget(`id(`drive), `Value);
		symbol ret = `none;

		if (SCR::Read(.target.size, target + "/content") != -1 )
		{
		    Popup::Message(_("Contents already exist in this directory.
Not copying CDs."));
		    ret = `next;
		}
		else
		{
		    ret = (symbol)CopyCDs(target, `onedir, iso, false, selecteddrive);
		}

		if (ret == `next)
		{
		    // ask for an addon only when the product is pre-CODE10
		    boolean ask_for_addon = false;

		    if (SCR::Read(.target.size, target + "/content") > 0)
		    {
			map content_file = ReadContentFile(target + "/content");
			y2debug("Parsed content file: %1", content_file);

			string product_lower = tolower(content_file["PRODUCT"]:"");
			string version_str = content_file["VERSION"]:"";

			y2milestone("product: %1", product_lower);
			y2milestone("version: %1", version_str);

			integer version_major = 0;
			integer version_minor = 0;

			if (issubstring(version_str, "."))
			{
			    list<string> parts = splitstring(version_str, ".");

			    version_major = tointeger(parts[0]:"0");
			    version_minor = tointeger(parts[1]:"0");
			}
			else
			{
			    version_major = tointeger(version_str);
			}

			y2milestone("major version number: %1", version_major);
			y2milestone("minor version number: %1", version_minor);

			integer version = 100 * version_major + version_minor;
			y2milestone("version: %1", version);

			// SUSE Linux <= 10.0
			if ( (product_lower == "suse linux" && version <= 1000) ||
			    // SLES or CORE == 9
			    ((product_lower == "suse sles" || product_lower == "suse core") && version == 900) )
			{
			    ask_for_addon = true;
			}
		    }

		    y2milestone("ask_for_addon: %1", ask_for_addon);

		    // for translators: popup question (prefer more shorter lines than few long lines)
		    while (ask_for_addon && Popup::YesNo(_("Add an additional product (Service Pack, Additional\nPackage CD, etc.) to the source?")) == true)
		    {
			CopyCDs(target, `onedir, iso, true, selecteddrive);
		    }
		}

		if (ret == `next)
		{
		    map content = $[];
		    string contentpath = sformat("%1/content", target);

		    Instserver::createOrderFiles(target);

		    if (SCR::Read(.target.size, contentpath) > 0 )
		    {
			content = (map)SCR::Read(.content_file, contentpath);
		    }
		    else
		    {
			y2error("cant read content file, something nasty happened: %1", contentpath);
		    }

		    y2debug("content: %1", content);
		    Instserver::Config = (map<string, any>)union(Instserver::Config, content);
		}
		else
		{
		    // copying has been aborted, remove the source
		    string cmd = "/bin/rm -rf " + target;
		    y2milestone("Removing directory %1", target);

                    if (SCR::Execute(.target.bash, cmd) != 0 )
                    {
			y2error("Cannot remove directory %1", target);
		    }

		    Instserver::Config = $[];
		}

		Instserver::UpdateConfig();
		Instserver::modified = true;
		break;
	    }
	    else {
		y2error("unexpected retcode: %1", ret);
		continue;
	    }
	}

	return ret;
    }

    /**
     * Source configuration dialog
     * @return dialog result
     */
    any SourceConfigDialog () {

        /* Instserver configuration dialog caption */
        string caption = _("Source Configuration");

        string dir = Instserver::Config["directory"]:"";
        boolean slp = Instserver::Config["slp"]:false;

        /* Instserver configure1 dialog contents */
        term contents =
            `HVSquash(
		      `VBox(
			    `Left(`TextEntry(`id(`dir), _("Source &Name:"), dir)),
			    `VSpacing(1),
			    `Left(
				  `CheckBox(`id(`slp), _("A&nnounce as Installation Service with SLP"), slp )
				  )
                            )
		      );

	Wizard::SetContentsButtons(caption, contents, HELPS["initial"]:"",
				   Label::BackButton(), Label::NextButton());

	map current = Instserver::Config;

	any ret = nil;
	while(true) {

	    ret = UI::UserInput();
	    dir = (string)UI::QueryWidget(`id(`dir), `Value);
            string target = Instserver::ServerSettings["directory"]:"" + "/" + dir;

	    /* abort? */
	    if (ret == `abort || ret == `cancel) {
		if (ReallyAbort()) break;
		else continue;
	    }
	    else if (ret == `back ) {
		break;
	    }
	    else if (ret == `next )
	    {
		if (dir == "")
		{
		    Popup::Error(_("Installation server name missing."));
		    continue;
		}
                else if (dir != filterchars (dir,
                                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.")
                        || size (dir) > 127
                        )
                {
                    string errmsg = _("Invalid source name.");
                    Popup::Error(errmsg);
                    continue;
                }
                else if (dir != Instserver::Config["name"]:"" && haskey(Instserver::Configs, dir)){
		    // an error message - entered source name already exists
		    Popup::Error(sformat(_("Source '%1' already exists,\nenter another name."), dir));
		    continue;
		}
		// create directory only for a new source
		else if (Instserver::Config == $[]) {
                    string mkdircmd = "mkdir -p " + target;

                    y2debug("executing: %1", mkdircmd );
                    if (SCR::Execute(.target.bash, mkdircmd) != 0 )
                    {
                        Popup::Error(sformat(_("Error while creating 'source' directory.
Verify that the directory 
 %1 
is writable and try again."), Instserver::ServerSettings["directory"]:""));
                        continue;
                    }
                }

		if (dir != Instserver::Config["name"]:"" && Instserver::Config["name"]:"" != "")
		{
		    // mark the directory content for moving at write
		    Instserver::renamed = add(Instserver::renamed, Instserver::Config["name"]:"", dir);

		    // remove the old configuration in Instserver::UpdateConfig()
		    Instserver::Config["old_name"] = Instserver::Config["name"]:"";
		}

		slp  = (boolean)UI::QueryWidget(`id(`slp), `Value);

		Instserver::Config["name"] = dir;
		Instserver::Config["directory"] = dir;
		Instserver::Config["slp"] = slp;

		if (current != $[])
		{
		    // update modified source now, the workflow has in this case only one step
		    Instserver::UpdateConfig();
		    Instserver::modified = true;
		}

		break;
	    }
	    else {
		y2error("unexpected retcode: %1", ret);
		continue;
	    }
	}

	return ret;
    }


    /**
     * Server dialog
     * @return dialog result
     */
    any ServerDialog () {

        /* Instserver server dialog caption */
        string caption = _("Initial Setup -- Servers");

        string dir = Instserver::ServerSettings["directory"]:"";
        boolean dry = Instserver::ServerSettings["dry"]:false;
        symbol source = Instserver::ServerSettings["service"]:`http;

        term c1 =
            `HBox(
		  `VBox(
                        `Left(`CheckBox(`id(`dry), `opt(`notify), _("Do Not Configure Any Net&work Services"))),
                        `VSquash(
				 `HBox(
				       `TextEntry(`id(`dir), _("Di&rectory to Contain Sources:"), dir),
				       `VBox(
					     `VSpacing(),
					     `Bottom(`PushButton(`id(`select_dir),
								 _("Select &Directory")))
					     )
				       )
				 )
                        )
		  );

        term buttons =
            `VBox (
		   // radio button label
		   `Left (`RadioButton (`id (`http),
					_("&Configure as HTTP Source"), source == `http)),
		   // radio button label
		   `Left (`RadioButton (`id (`ftp),
					_("&Configure as FTP Source"), source == `ftp)),
		   // radio button label
		   `Left (`RadioButton (`id (`nfs),
					_("&Configure as NFS Source"), source == `nfs))

		   );

        /* Instserver configure2 dialog contents */
        term contents =
            `HVSquash(
		      `VBox(
			    `RadioButtonGroup (
					       `id (`service),
					       buttons
					       ),
			    `VSpacing(1),
			    c1
			    )
		      );

        Wizard::SetContentsButtons(caption, contents, HELPS["server"]:"server",
				   Label::BackButton(), Label::NextButton());

        any ret = nil;
        while(true) {

            dry = (boolean)UI::QueryWidget(`id(`dry), `Value);
            if (dry)
            {
                UI::ChangeWidget(`id(`service), `Enabled, false);
            } else {
                UI::ChangeWidget(`id(`service), `Enabled, true);
            }

            ret = UI::UserInput();

            source = (symbol)UI::QueryWidget(`id(`service), `CurrentButton);
            dir = (string)UI::QueryWidget(`id(`dir), `Value);

            /* abort? */
            if(ret == `abort || ret == `cancel) {
                if(ReallyAbort()) break;
                else continue;
            }
            else if (ret ==`select_dir)
            {
                any new_dir = UI::AskForExistingDirectory( dir, _("Select Directory"));
                if (new_dir != nil)
                {
                    UI::ChangeWidget(`id(`dir), `Value, (string) new_dir);
                }
                continue;
            }

            else if(ret == `back ) {
                break;
            }
            else if(ret == `next )
            {
                boolean r = false;
                if (dir == "")
                {
                    Popup::Error(_("Directory path for the installation server missing."));
                    continue;
                }
                Instserver::ServerSettings["service"] = source;
                Instserver::ServerSettings["dry"] = dry;
                Instserver::ServerSettings["directory"] = dir;
                Instserver::modified = true;
                if (dry)
                    ret = `next;
                else
                    ret = source;
                break;
            }
            else if (ret != `dry) {
		y2error("unexpected retcode: %1", ret);
                continue;
            }
        }

        return ret;
    }

    /**
     * NFS dialog
     * @return dialog result
     */
    any NfsDialog () {

        /* Instserver configure2 dialog caption */
        string caption = _("Installation Server -- NFS");

        string nfsoptions = "ro,root_squash,sync";
        string wildcard = "*";

        /* Instserver nfs dialog contents */
        term contents =
            `HVSquash( 
		      `VBox(
			    `Left(`TextEntry(`id(`wildcard), _("&Host Wild Card"), wildcard)),
			    `Left(`TextEntry(`id(`nfsoptions), _("&Options"), nfsoptions))
			    )
		      );


        Wizard::SetContentsButtons(caption, contents, HELPS["nfs"]:"nfs",
				   Label::BackButton(), Label::NextButton());

        any ret = nil;
        while(true) {

            ret = UI::UserInput();

            /* abort? */
            if(ret == `abort || ret == `cancel) {
                if(ReallyAbort()) break;
                else continue;
            }
            else if(ret == `back ) {
                break;
            }
            else if(ret == `next ) {
                boolean r = false;
                nfsoptions = (string)UI::QueryWidget(`id(`nfsoptions), `Value);
                wildcard = (string)UI::QueryWidget(`id(`wildcard), `Value);
                if (!Instserver::ServerSettings["dry"]:false)
                {
                    r = Instserver::SetupNFS(Instserver::ServerSettings["directory"]:"" , wildcard + "(" + deletechars(nfsoptions," ") + ")" );
                    if (!r)
                    {
                        Popup::Error(_("Error occurred while configuring NFS."));
                        continue;
                    }
                }
                Instserver::modified = true;
                break;
            }
            else {
                y2error("unexpected retcode: %1", ret);
                continue;
            }
        }

        return ret;
    }


    /**
     * Ftp dialog
     * @return dialog result
     */
    any FtpDialog () {

        /* Instserver configure2 dialog caption */
        string caption = _("Installation Server -- FTP");

        string ftproot = Instserver::ServerSettings["ftproot"]:"/srv/ftp";
        string ftpalias = Instserver::ServerSettings["ftpalias"]:"";
        /* Instserver nfs dialog contents */
        term contents =
            `HVSquash(
		      `VBox(
			    `Left(`TextEntry(`id(`ftproot), _("&FTP Server Root Directory:"), ftproot )),
			    `Left(`TextEntry(`id(`ftpalias), _("&Directory Alias:"), ftpalias ))
			    )
		      );


        Wizard::SetContentsButtons(caption, contents, HELPS["ftp"]:"ftp",
				   Label::BackButton(), Label::NextButton());

        any ret = nil;
        while(true) {

            ret = UI::UserInput();

            ftproot = (string)UI::QueryWidget(`id(`ftproot), `Value);
	    ftpalias = (string)UI::QueryWidget(`id(`ftpalias), `Value);

            /* abort? */
            if(ret == `abort || ret == `cancel) {
                if(ReallyAbort()) break;
                else continue;
            }
            else if(ret == `back ) {
                break;
            }
            else if(ret == `next ) {
                boolean r = false;
                Instserver::ServerSettings["ftproot"] = ftproot;
                Instserver::ServerSettings["ftpalias"] = ftpalias;
                if (!Instserver::ServerSettings["dry"]:false)
                {
                    r = Instserver::SetupFTP(Instserver::ServerSettings["directory"]:"" , ftproot , ftpalias);
                    if (!r)
                    {
                        Popup::Error(_("Error occurred while configuring FTP."));
                        ret = `back;
                        break;
                    }
                }
                Instserver::modified = true;
                break;
            }
            else {
                y2error("unexpected retcode: %1", ret);
                continue;
            }
        }

        return ret;
    }

    /**
     * Http dialog
     * @return dialog result
     */
    any HttpDialog () {

        /* Instserver configure2 dialog caption */
        string caption = _("Installation Server -- HTTP");

        string alias = Instserver::ServerSettings["alias"]:"";
        /* Instserver nfs dialog contents */
        term contents =
            `HVSquash(
		      `VBox(
			    `Left(`TextEntry(`id(`alias), _("&Directory Alias"), alias ))
			    )
		      );


        Wizard::SetContentsButtons(caption, contents, HELPS["http"]:"http",
				   Label::BackButton(), Label::NextButton());

        any ret = nil;
        while(true) {

            ret = UI::UserInput();

            /* abort? */
            if(ret == `abort || ret == `cancel) {
                if(ReallyAbort()) break;
                else continue;
            }
            else if(ret == `back ) {
                break;
            }
            else if(ret == `next ) {
                alias = (string)UI::QueryWidget(`id(`alias), `Value);
                Instserver::ServerSettings["alias"] = alias;
                if (!Instserver::ServerSettings["dry"]:false)
                {
                    if (!Instserver::SetupHTTP(Instserver::ServerSettings["directory"]:"", alias))
                    {
                        Popup::Error(_("Error creating HTTPD configuration."));
                        ret = `back;
                        break;
                    }
                }
                Instserver::modified = true;
                break;
            }
            else {
                y2error("unexpected retcode: %1", ret);
                continue;
            }
        }

        return ret;
    }


    /* EOF */
}
