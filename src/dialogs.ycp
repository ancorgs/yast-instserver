/**
 * File:	include/instserver/dialogs.ycp
 * Package:	Configuration of instserver
 * Summary:	Dialogs definitions
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */

{

    textdomain "instserver";

    import "Installation";
    import "Label";
    import "Popup";
    import "Wizard";
    import "Instserver";

    include "instserver/helps.ycp";
    include "instserver/routines.ycp";



    /**
     * CD Popup
     * @param string popup message
     * @param boolean true if ISO
     * @return any
     */
    any CDPopup (string msg, boolean iso)
	{
	    if (iso)
	    {
		any f = UI::AskForExistingFile( Instserver::ServerSettings["iso-dir"]:"", "*.iso", msg );
		y2milestone("file: %1", f);
		if (f!= nil)
		{
		    return f;
		}
		else
		{
		    return "";
		}
	    }
	    else
	    {
		symbol pop =  Popup::AnyQuestion3(_("Change Media"),
						  msg,
						  Label::ContinueButton(),
						  _("Ski&p"),
						  Label::CancelButton(),
						  `focus_yes );
		if (pop == `retry)
		{
		    return `abort;
		}
		else if (pop == `no)
		{
		    y2debug("skipping media");
		    return `skip;
		}
	    }
	}


    /**
     * Copy CDs to local disk
     * @param string directory
     * @param symbol source type
     * @param boolean true if copying using ISO files
     * @param boolean prompt for additional CDs.
     * @return any
     */
    any CopyCDs( string dir, symbol stype, boolean iso, boolean promptmore, string cddrive)
	{

	    // free mount point
	    SCR::Execute (.target.umount, Installation::sourcedir);


	    string default_device = cddrive;
	    string mount_options = "";
	    any result = nil;


	    // CD is mounted. Check contents.
	    string cdpath = Installation::sourcedir;

	    integer current_cd = 1;
	    integer total_cds = 1;
	    boolean standalone = true;
	    boolean baseproduct = false;
	    string base = "";
	    string basever = "";
            string prompt_string = "";
            string prompt_version = "";
            integer prompt_totalcds = 0;
            string medianame = "";
            boolean doublesided = false;
            list medianames = [];
            boolean failed = false;
            boolean cds_copied = false;

            string media_id = "";

            boolean restart = false;

	    symbol pop = `none;

            // Fix for mounting ISO images over NFS
	    if (iso)
	    {
		mount_options = "-oloop,ro ";
	    } 
            else
            {
		mount_options = "";
            }

	    // Loop for all CDs
	    while (true)
	    {
		string msg = "";
		if (!baseproduct && standalone && size(medianames) == 0)
		{
		    // %1 is the current cd number
		    if (!iso)
			msg = sformat(_("Insert CD %1 then press continue."), current_cd );
		    else
			msg = sformat(_("Select ISO image %1 then press continue."), current_cd );
		}
		else
		{
		    // %2 is the product name and version
                    string cd_prompt = _("Insert CD %1 of %2.");
                    string iso_prompt = _("Select ISO image %1 of %2.");
                    integer prompt_for_cd = 0;

                    if (promptmore  || (!standalone && !baseproduct) && !restart)
                    {
                        prompt_for_cd = current_cd;
                    }
                    else
                    {
                        prompt_for_cd = prompt_totalcds + current_cd;
                    }

		    if (!iso)
                    {
                        if (size(medianames) == 0)
                        {
			    msg = sformat(cd_prompt, prompt_for_cd,
                                    prompt_string );
                        }
                        else
                        {
                            string m = "";
                            y2milestone("medianames: %1, totalcds: %2",
                                    size(medianames), total_cds );
                            if (size(medianames) > 1 )
                            {
                                y2milestone("all media names available");
                                m = medianames[prompt_for_cd - 1]:"";
                            }
                            else
                            {
                                prompt_string =
                                    substring(regexpsub(medianames[0]:"",
                                                "(.*)CD.", "\\1CD%1"), 7,
                                            size(medianames[0]:""));
                                m = sformat(prompt_string, prompt_for_cd);
                            }
                            msg =sformat("Insert\n%1", m);
                        }
                    }
		    else
                    {
                        if (size(medianames) == 0)
                        {
			    msg = sformat(iso_prompt, prompt_for_cd,
                                    prompt_string );
                        }
                        else
                        {
                            string m = "";
                            y2milestone("medianames: %1, totalcds: %2",
                                    size(medianames), total_cds );
                            if (size(medianames) > 1 )
                            {
                                y2milestone("all media names available");
                                m = medianames[prompt_for_cd - 1]:"";
                            }
                            else
                            {
                                prompt_string =
                                    regexpsub(medianames[0]:"",
                                                "(.*)CD.", "\\1CD%1");
                                y2debug("prompt string: %1)", prompt_string);
                                m = sformat(prompt_string, prompt_for_cd);
                            }
                            msg = sformat("Select %1", m);
                        }
                    }
		}


		if (iso)
		{
		    default_device = (string)CDPopup(msg, iso);
		    if  ( default_device == "")
		    {
                        y2debug("total_cds: %1, current_cd: %2", total_cds, current_cd);
			if (total_cds == current_cd)
			{
                            failed = !cds_copied;
			    break;
			}
			else
			{
			    current_cd = current_cd + 1;
			    continue;
			}
		    }
		}
		else
		{
		    pop = (symbol)CDPopup(msg, iso);
		    if (pop == `skip)
		    {
			if (total_cds == current_cd )
			{
			    break;
			}
			else
			{
			    current_cd = current_cd + 1;
			    continue;
			}
		    }
		    else if ( pop == `abort)
		    {
			return `abort;
		    }
		}

		// try to mount device
		if (SCR::Execute (.target.mount, [ default_device, Installation::sourcedir], mount_options) == false)
		{
		    // cant mount /dev/cdrom popup
		    y2error("mount faild");
		    continue;
		}
		y2debug("mounted cdrom");

		list<string> media = ReadMediaFile( sformat("%1/media.%2/media", cdpath, current_cd ));
		y2debug("media: %1", media);
		map content = $[];

		if (size(media) == 0  || (media_id != media[1]:"" && media_id!="") )
		{
		    y2debug("wrong CD or non suse CD");
		    SCR::Execute (.target.umount, Installation::sourcedir);
		    continue;
		}
		else
		{
		    content = ReadContentFile(cdpath + "/content");
                    y2debug("Content file: %1", content);
		    if (media[2]:"" != "" && media[2]:"" != "doublesided")
		    {
			total_cds = tointeger(media[2]:"-1");
                        media_id = media[1]:"";
			y2debug("total cds expected: %1", total_cds);
		    }

                    y2debug("base: %1 basever: %2", base, basever );

                    // Bug 47599: CD2 of SP1 not copied
		    if (content["PRODUCT"]:"dummy" != base && content["VERSION"]:"dummy" != basever  && !standalone)
		    {
                        /*
                         *  Check if this CD set is based on the base product (CORE)
                         */
                        if ( content["BASEPRODUCT"]:"dummy" != base && content["BASEVERSION"]:"dummy" != basever )
                        {
			    SCR::Execute (.target.umount, Installation::sourcedir);
			    continue;
                        }
		    }

                    foreach(string m, media, ``{
                            if (m == "doublesided")
                            doublesided = true;

                            if (substring(m, 0, 5 ) == "MEDIA" )
                            {
                            if (doublesided)
                                medianame = regexpsub(m, "(.*)SIDE A(.*)", "\\1SIDE %1\\2");
                            else
                                medianame = regexpsub(m, "(.*)CD.", "\\1CD%1");

                            medianames=add(medianames, substring(m,7,
                                    size(m)));
                            }
                            });
                    y2milestone("medianames: %1", medianames);
		}


		string distprod = content["LABEL"]:"";
                string flags = content["FLAGS"]:"";
                list<string> flaglist = splitstring(flags, " ");

                // Detect SP
                if (contains(flaglist, "SP"))
                {
                    Instserver::is_service_pack = true;
                    y2milestone("Service Pack detected..");
                } else {
                    Instserver::is_service_pack = false;
                }


		list<string> l = splitstring(distprod, " ");
		distprod = mergestring(l, "-");
		string tgt = sformat("%1/%2/CD%3", dir, distprod, current_cd );
		y2debug("tgt: %1", tgt );

		string shorttgt = sformat("%1/CD%2",  distprod, current_cd );
		y2debug("shorttgt: %1", shorttgt );

		list<string> cmds = [];

		// Copy stuff here.
		// Now, we check if this product on the CD is based on some other product. If
		// yes, then it will be copied into  a sub-directory and not in the requested
		// root.

		// This product is based on some other product
		if ( tolower(content["BASEPRODUCT"]:"") != "" && content["BASEVERSION"]:"" != "")
		{
                    // first sles cd goes in here.
                    // Also any non base products, i.e. SDK and SP
		    map basecontent = $[];

                    // Read content file if source already exists.
		    if (promptmore || Instserver::is_service_pack)
		    {
			basecontent = ReadContentFile(dir + "/content");
			if (tolower(content["BASEPRODUCT"]:"") == tolower(basecontent["BASEPRODUCT"]:"")
			    && content["BASEVERSION"]:"" == basecontent["BASEVERSION"]:"" )
			{
			    // Same base product => OK
			    y2milestone("matching base product");
			}
                        else
                        {
			    // add-on medium (e.g. service pack) doesn't match configured source
                            Report::LongError(sformat(_("The medium requires product '%1'.\nThe configured installation source provides product '%2'.\n\nSelect the right add-on product."), content["BASEPRODUCT"]:"", basecontent["BASEPRODUCT"]:""));
                            media_id = "";
                            continue;
                        }
		    }
		    base = content["BASEPRODUCT"]:""; // i.e. SUSE CORE
		    basever = content["BASEVERSION"]:""; // i.e. 9

		    // its not standalone
		    standalone = false;

		    // and its not a base product
		    baseproduct = false;

                    // No media names, so we have to create the string for media request
                    if (size(medianames) == 0)
                    {
                        prompt_string = content["LABEL"]:"";
                        prompt_version = content["VERSION"]:"";
                    }
                    else
                    {
                        prompt_version = "";
                    }

                    prompt_totalcds = total_cds;

		    if ( current_cd == 1 )
		    {
			map proddata = $["standalone": false, "baseproduct": false , "name": distprod ];
			Instserver::products = add(Instserver::products, proddata );
		    }

		    // Create product dir
		    SCR::Execute(.target.mkdir, tgt );
		    y2debug("config=%1, products=%2", Instserver::Config,
			    Instserver::products);

		}
		else if (content["PRODUCT"]:"dummy" == base && content["VERSION"]:"dummy" == basever )
		{
		    if ( current_cd == 1 )
		    {
			map proddata = $["standalone": true, "baseproduct": true , "name": distprod ];
			Instserver::products = add(Instserver::products, proddata );
		    }
		    standalone = true;
		    baseproduct = true;
		    SCR::Execute(.target.mkdir, tgt );
		    y2debug("config=%1, products=%2", Instserver::Config,
			    Instserver::products);
		}
		else
		{
		    if ( current_cd == 1 )
		    {
			map proddata = $["standalone": true, "baseproduct": true , "name": distprod ];
			Instserver::products = add(Instserver::products, proddata );
		    }
		    standalone = true;
		    baseproduct = true;
                    if (size(medianames) == 0)
                    {
                        prompt_string = content["LABEL"]:"";
                        prompt_version = content["VERSION"]:"";
                    }
                    else
                    {
                        prompt_version = "";
                    }
		    // else, we create CD1, CD2, etc.
		    if (stype == `onedir)
			tgt = sformat("%1/", dir);
		    else
			tgt = sformat("%1/CD%2", dir, current_cd );
		    y2debug("tgt: %1", tgt );
		    SCR::Execute(.target.mkdir, tgt);
		    y2debug("config=%1, products=%2", Instserver::Config,
			    Instserver::products);
		}

		Popup::ShowFeedback(_("Copying CD contents to local directory"), _("This may take a while..."));

		// Do actual copying of data
		if (Instserver::test)
		{
		    cmds = add(cmds, sformat("cp -pR %1/media.%2 %3", cdpath,
					     current_cd, tgt) );
		    cmds = add(cmds, sformat("cp  %1/content %2", cdpath,
					     tgt));
		}
		else
		{
                    cmds = add(cmds, sformat("cd %1 && tar cf - . | (cd %2  && tar xBf -)", cdpath,  tgt) );
		}


		list<string> files= [];
		// Link files
		if (!standalone && current_cd == 1)
		{
		    if (promptmore)
		    {
			files = ["driverupdate", "linux"];
			// TODO replace boot link by a directory, set root and rescue links #95413
		    }
		    else
		    {
			files = ["control.xml", "content", "media.1" , "boot"];
		    }
		    cmds = (list<string>)union(cmds, Instserver::createLinks( dir, distprod, files ) );
		}

		if (size(cmds) > 0 )
		{
		    foreach(string cmd , cmds, ``{
                        y2debug("executing command: %1", cmd );
                        SCR::Execute(.target.bash, cmd);
		    });
		    cmds = [];
                    cds_copied= true;
		}


		Popup::ClearFeedback();

		SCR::Execute (.target.umount, Installation::sourcedir);

		if (total_cds == current_cd && !standalone && !baseproduct &&
                        !promptmore)
		{
                    y2debug("Restarting...");
                    restart = true;
		    current_cd = 1;
                    media_id = "";
                    if (size(medianames) == 0)
                    {
                        prompt_string = base;
                        prompt_version = basever;
                    }
		}
		else if ( total_cds == current_cd && ( standalone || baseproduct) )
		{
		    break;
		}
		else if ( total_cds == current_cd && promptmore )
		{
		    break;
		}
		else
		{
		    current_cd = current_cd + 1;
                    y2debug("next cd: %1", current_cd );
		}
		Instserver::standalone = standalone;
	    }
            if (failed)
            {
                return `abort;
            }

	    return `next;
	}

    define list<term> CDdevices() {
	list<map> cds = (list<map>)SCR::Read(.probe.cdrom);
	list<term> ret = [];

	if (cds != nil)
	{
	    foreach(map cd, cds, {
		    string dev = cd["dev_name"]:"";
		    string model = cd["model"]:"";

		    if (dev != nil && dev != "" && model != nil)
		    {
			ret = add(ret, `item(`id(dev), model + sformat(" (%1)", dev)));
		    }
		}
	    );
	}

	return ret;
    }

    /**
     * Source configuration dialog
     * @return dialog result
     */
    any MediaDialog () {

        /* Instserver configuration dialog caption */
        string caption = _("Source Configuration");

        string isodir = Instserver::ServerSettings["iso-dir"]:"";
	list<term> cddevs = CDdevices();
        boolean iso = (size(cddevs) == 0);

        /* Instserver configure1 dialog contents */
        term contents =
            `HVSquash(
		      `VBox(
			    `RadioButtonGroup(`id(`rbg),
				`VBox(
				    `Left(`RadioButton(`id(`disk), `opt(`notify),  _("Read &CD/DVD Medium"), iso == false )),
				     `HBox(
					    `HSpacing(3),
					    `ComboBox(`id(`drive), _("Data &source"), cddevs),
					    `HStretch()
				     ),
				    `VSpacing(1),
				    `Left(`RadioButton(`id(`iso), `opt(`notify),  _("Use &ISO Images"), iso == true))
				)
			    ),
			    `VSquash(
				     `HBox(
					    `HSpacing(3),
					    `TextEntry(`id(`isodir),  _("Di&rectory with CD Images:"), isodir),
					    `VBox(
						 `VSpacing(),
						 `Bottom(`PushButton(`id(`select_dir), _("Select &Directory")))
						 )
					   )
				     )
		      )
	    );

	Wizard::SetContentsButtons(caption, contents, HELPS["initial2"]:"",
				   Label::BackButton(), Label::NextButton());

	UI::ChangeWidget(`id(`isodir), `Enabled, iso);
	UI::ChangeWidget(`id(`select_dir), `Enabled, iso);

	// disable CD widgets when there is no drive detected
	if (size(cddevs) == 0)
	{
	    UI::ChangeWidget(`id(`disk), `Enabled, false);
	    UI::ChangeWidget(`id(`drive), `Enabled, false);
	}

	any ret = nil;
	while(true) {
	    ret = UI::UserInput();

	    /* abort? */
	    if (ret == `abort || ret == `cancel) {
		if (ReallyAbort()) break;
		else continue;
	    }
	    else if(ret == `back ) {
		break;
	    }
	    else if (ret == `disk || ret == `iso)
	    {
		iso = (boolean)UI::QueryWidget(`id(`iso) , `Value);
		UI::ChangeWidget(`id(`isodir), `Enabled, iso);
		UI::ChangeWidget(`id(`select_dir), `Enabled, iso);
		UI::ChangeWidget(`id(`drive), `Enabled, !iso);
	    }
	    else if (ret == `select_dir)
	    {
		any new_dir = UI::AskForExistingDirectory( isodir, _("Select Directory"));
		if (new_dir != nil)
		{
		    UI::ChangeWidget(`id(`isodir), `Value, (string) new_dir);
		}
		continue;
	    }
	    else if (ret == `next)
	    {
		boolean iso = (boolean)UI::QueryWidget(`id(`iso), `Value);
		string dir = Instserver::Config["directory"]:"";
		string target = Instserver::ServerSettings["directory"]:"" + "/" + dir;

		if (dir == "")
		{
		    Popup::Error(_("Installation server name missing."));
		    continue;
		}

		Instserver::ServerSettings["iso-dir"] = (string)UI::QueryWidget(`id(`isodir), `Value);

		string selecteddrive = (string)UI::QueryWidget(`id(`drive), `Value);
		symbol ret = `none;

		if (SCR::Read(.target.size, target + "/content") != -1 )
		{
		    Popup::Message(_("Contents already exist in this directory.
Not copying CDs."));
		    ret = `next;
		}
		else
		{
		    ret = (symbol)CopyCDs(target, `onedir, iso, false, selecteddrive);
		}

		// for translators: popup question (prefer more shorter lines than few long lines)
		while (Popup::YesNo(_("Add an additional product (Service Pack, Additional\nPackage CD, etc.) to the source?")) == true)
		{
		    ret = (symbol)CopyCDs(target, `onedir, iso, true, selecteddrive);
		}

		if (ret == `next)
		{
		    map content = $[];
		    string contentpath = sformat("%1/content", target);

		    Instserver::createOrderFiles(target);

		    if (SCR::Read(.target.size, contentpath) > 0 )
		    {
			content = (map)SCR::Read(.content_file, contentpath);
		    }
		    else
		    {
			y2error("cant read content file, something nasty happened: %1", contentpath);
		    }

		    y2debug("content: %1", content);
		    Instserver::Config = (map<string, any>)union(Instserver::Config, content);
		}
		else
		{
		    // copying has been aborted, remove the source
		    string cmd = "/bin/rm -rf " + target;
		    y2milestone("Removing directory %1", target);

                    if (SCR::Execute(.target.bash, cmd) != 0 )
                    {
			y2error("Cannot remove directory %1", target);
		    }

		    Instserver::Config = $[];
		}

		Instserver::UpdateConfig();
		Instserver::modified = true;
		break;
	    }
	    else {
		y2error("unexpected retcode: %1", ret);
		continue;
	    }
	}

	return ret;
    }

    /**
     * Source configuration dialog
     * @return dialog result
     */
    any SourceConfigDialog () {

        /* Instserver configuration dialog caption */
        string caption = _("Source Configuration");

        string dir = Instserver::Config["directory"]:"";
        boolean slp = Instserver::Config["slp"]:false;

        /* Instserver configure1 dialog contents */
        term contents =
            `HVSquash(
		      `VBox(
			    `Left(`TextEntry(`id(`dir), _("Source &Name:"), dir)),
			    `VSpacing(1),
			    `Left(
				  `CheckBox(`id(`slp), _("A&nnounce as Installation Service with SLP"), slp )
				  )
                            )
		      );

	Wizard::SetContentsButtons(caption, contents, HELPS["initial"]:"",
				   Label::BackButton(), Label::NextButton());

	map current = Instserver::Config;

	any ret = nil;
	while(true) {

	    ret = UI::UserInput();
	    dir = (string)UI::QueryWidget(`id(`dir), `Value);
            string target = Instserver::ServerSettings["directory"]:"" + "/" + dir;

	    /* abort? */
	    if (ret == `abort || ret == `cancel) {
		if (ReallyAbort()) break;
		else continue;
	    }
	    else if (ret == `back ) {
		break;
	    }
	    else if (ret == `next )
	    {
		if (dir == "")
		{
		    Popup::Error(_("Installation server name missing."));
		    continue;
		}
                else if (dir != filterchars (dir,
                                "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.")
                        || size (dir) > 127
                        )
                {
                    string errmsg = _("Invalid source name.");
                    Popup::Error(errmsg);
                    continue;
                }
                else if (dir != Instserver::Config["name"]:"" && haskey(Instserver::Configs, dir)){
		    // an error message - entered source name already exists
		    Popup::Error(sformat(_("Source '%1' already exists,\nenter another name."), dir));
		    continue;
		}
		// create directory only for a new source
		else if (Instserver::Config == $[]) {
                    string mkdircmd = "mkdir -p " + target;

                    y2debug("executing: %1", mkdircmd );
                    if (SCR::Execute(.target.bash, mkdircmd) != 0 )
                    {
                        Popup::Error(sformat(_("Error while creating 'source' directory.
Verify that the directory 
 %1 
is writable and try again."), Instserver::ServerSettings["directory"]:""));
                        continue;
                    }
                }

		if (dir != Instserver::Config["name"]:"" && Instserver::Config["name"]:"" != "")
		{
		    // mark the directory content for moving at write
		    Instserver::renamed = add(Instserver::renamed, Instserver::Config["name"]:"", dir);

		    // remove the old configuration in Instserver::UpdateConfig()
		    Instserver::Config["old_name"] = Instserver::Config["name"]:"";
		}

		slp  = (boolean)UI::QueryWidget(`id(`slp), `Value);

		Instserver::Config["name"] = dir;
		Instserver::Config["directory"] = dir;
		Instserver::Config["slp"] = slp;

		if (current != $[])
		{
		    // update modified source now, the workflow has in this case only one step
		    Instserver::UpdateConfig();
		    Instserver::modified = true;
		}

		break;
	    }
	    else {
		y2error("unexpected retcode: %1", ret);
		continue;
	    }
	}

	return ret;
    }


    /**
     * Server dialog
     * @return dialog result
     */
    any ServerDialog () {

        /* Instserver server dialog caption */
        string caption = _("Initial Setup -- Servers");

        string dir = Instserver::ServerSettings["directory"]:"";
        boolean dry = Instserver::ServerSettings["dry"]:false;
        symbol source = Instserver::ServerSettings["service"]:`http;

        term c1 =
            `HBox(
		  `VBox(
                        `Left(`CheckBox(`id(`dry), `opt(`notify), _("Do Not Configure Any Net&work Services"))),
                        `VSquash(
				 `HBox(
				       `TextEntry(`id(`dir), _("Di&rectory to Contain Sources:"), dir),
				       `VBox(
					     `VSpacing(),
					     `Bottom(`PushButton(`id(`select_dir),
								 _("Select &Directory")))
					     )
				       )
				 )
                        )
		  );

        term buttons =
            `VBox (
		   // radio button label
		   `Left (`RadioButton (`id (`http),
					_("&Configure as HTTP Source"), source == `http)),
		   // radio button label
		   `Left (`RadioButton (`id (`ftp),
					_("&Configure as FTP Source"), source == `ftp)),
		   // radio button label
		   `Left (`RadioButton (`id (`nfs),
					_("&Configure as NFS Source"), source == `nfs))

		   );

        /* Instserver configure2 dialog contents */
        term contents =
            `HVSquash(
		      `VBox(
			    `RadioButtonGroup (
					       `id (`service),
					       buttons
					       ),
			    `VSpacing(1),
			    c1
			    )
		      );

        Wizard::SetContentsButtons(caption, contents, HELPS["server"]:"server",
				   Label::BackButton(), Label::NextButton());

        any ret = nil;
        while(true) {

            dry = (boolean)UI::QueryWidget(`id(`dry), `Value);
            if (dry)
            {
                UI::ChangeWidget(`id(`service), `Enabled, false);
            } else {
                UI::ChangeWidget(`id(`service), `Enabled, true);
            }

            ret = UI::UserInput();

            source = (symbol)UI::QueryWidget(`id(`service), `CurrentButton);
            dir = (string)UI::QueryWidget(`id(`dir), `Value);

            /* abort? */
            if(ret == `abort || ret == `cancel) {
                if(ReallyAbort()) break;
                else continue;
            }
            else if (ret ==`select_dir)
            {
                any new_dir = UI::AskForExistingDirectory( dir, _("Select Directory"));
                if (new_dir != nil)
                {
                    UI::ChangeWidget(`id(`dir), `Value, (string) new_dir);
                }
                continue;
            }

            else if(ret == `back ) {
                break;
            }
            else if(ret == `next )
            {
                boolean r = false;
                if (dir == "")
                {
                    Popup::Error(_("Directory path for the installation server missing."));
                    continue;
                }
                Instserver::ServerSettings["service"] = source;
                Instserver::ServerSettings["dry"] = dry;
                Instserver::ServerSettings["directory"] = dir;
                Instserver::modified = true;
                if (dry)
                    ret = `next;
                else
                    ret = source;
                break;
            }
            else if (ret != `dry) {
		y2error("unexpected retcode: %1", ret);
                continue;
            }
        }

        return ret;
    }

    /**
     * NFS dialog
     * @return dialog result
     */
    any NfsDialog () {

        /* Instserver configure2 dialog caption */
        string caption = _("Installation Server -- NFS");

        string nfsoptions = "ro,root_squash,sync";
        string wildcard = "*";

        /* Instserver nfs dialog contents */
        term contents =
            `HVSquash( 
		      `VBox(
			    `Left(`TextEntry(`id(`wildcard), _("&Host Wild Card"), wildcard)),
			    `Left(`TextEntry(`id(`nfsoptions), _("&Options"), nfsoptions))
			    )
		      );


        Wizard::SetContentsButtons(caption, contents, HELPS["nfs"]:"nfs",
				   Label::BackButton(), Label::NextButton());

        any ret = nil;
        while(true) {

            ret = UI::UserInput();

            /* abort? */
            if(ret == `abort || ret == `cancel) {
                if(ReallyAbort()) break;
                else continue;
            }
            else if(ret == `back ) {
                break;
            }
            else if(ret == `next ) {
                boolean r = false;
                nfsoptions = (string)UI::QueryWidget(`id(`nfsoptions), `Value);
                wildcard = (string)UI::QueryWidget(`id(`wildcard), `Value);
                if (!Instserver::ServerSettings["dry"]:false)
                {
                    r = Instserver::SetupNFS(Instserver::ServerSettings["directory"]:"" , wildcard + "(" + deletechars(nfsoptions," ") + ")" );
                    if (!r)
                    {
                        Popup::Error(_("Error occurred while configuring NFS."));
                        continue;
                    }
                }
                Instserver::modified = true;
                break;
            }
            else {
                y2error("unexpected retcode: %1", ret);
                continue;
            }
        }

        return ret;
    }


    /**
     * Ftp dialog
     * @return dialog result
     */
    any FtpDialog () {

        /* Instserver configure2 dialog caption */
        string caption = _("Installation Server -- FTP");

        string ftproot = Instserver::ServerSettings["ftproot"]:"/srv/ftp";
        string ftpalias = Instserver::ServerSettings["ftpalias"]:"";
        /* Instserver nfs dialog contents */
        term contents =
            `HVSquash(
		      `VBox(
			    `Left(`TextEntry(`id(`ftproot), _("&FTP Server Root Directory:"), ftproot )),
			    `Left(`TextEntry(`id(`ftpalias), _("&Directory Alias:"), ftpalias ))
			    )
		      );


        Wizard::SetContentsButtons(caption, contents, HELPS["ftp"]:"ftp",
				   Label::BackButton(), Label::NextButton());

        any ret = nil;
        while(true) {

            ret = UI::UserInput();

            ftproot = (string)UI::QueryWidget(`id(`ftproot), `Value);
	    ftpalias = (string)UI::QueryWidget(`id(`ftpalias), `Value);

            /* abort? */
            if(ret == `abort || ret == `cancel) {
                if(ReallyAbort()) break;
                else continue;
            }
            else if(ret == `back ) {
                break;
            }
            else if(ret == `next ) {
                boolean r = false;
                Instserver::ServerSettings["ftproot"] = ftproot;
                Instserver::ServerSettings["ftpalias"] = ftpalias;
                if (!Instserver::ServerSettings["dry"]:false)
                {
                    r = Instserver::SetupFTP(Instserver::ServerSettings["directory"]:"" , ftproot , ftpalias);
                    if (!r)
                    {
                        Popup::Error(_("Error occurred while configuring FTP."));
                        ret = `back;
                        break;
                    }
                }
                Instserver::modified = true;
                break;
            }
            else {
                y2error("unexpected retcode: %1", ret);
                continue;
            }
        }

        return ret;
    }

    /**
     * Http dialog
     * @return dialog result
     */
    any HttpDialog () {

        /* Instserver configure2 dialog caption */
        string caption = _("Installation Server -- HTTP");

        string alias = Instserver::ServerSettings["alias"]:"";
        /* Instserver nfs dialog contents */
        term contents =
            `HVSquash(
		      `VBox(
			    `Left(`TextEntry(`id(`alias), _("&Directory Alias"), alias ))
			    )
		      );


        Wizard::SetContentsButtons(caption, contents, HELPS["http"]:"http",
				   Label::BackButton(), Label::NextButton());

        any ret = nil;
        while(true) {

            ret = UI::UserInput();

            /* abort? */
            if(ret == `abort || ret == `cancel) {
                if(ReallyAbort()) break;
                else continue;
            }
            else if(ret == `back ) {
                break;
            }
            else if(ret == `next ) {
                alias = (string)UI::QueryWidget(`id(`alias), `Value);
                Instserver::ServerSettings["alias"] = alias;
                if (!Instserver::ServerSettings["dry"]:false)
                {
                    if (!Instserver::SetupHTTP(Instserver::ServerSettings["directory"]:"", alias))
                    {
                        Popup::Error(_("Error creating HTTPD configuration."));
                        ret = `back;
                        break;
                    }
                }
                Instserver::modified = true;
                break;
            }
            else {
                y2error("unexpected retcode: %1", ret);
                continue;
            }
        }

        return ret;
    }


    /* EOF */
}
